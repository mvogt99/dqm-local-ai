"""
Data Quality Routes Test Suite
Generated by: RTX 3050 (initial), RTX 5090 (review), Expert AI (final corrections)
Following TDD principles with comprehensive coverage
"""
import pytest
from httpx import AsyncClient, ASGITransport
from unittest.mock import AsyncMock, MagicMock, patch
from typing import List, Dict, Any

# Test configuration
TEST_BASE_URL = "http://test"


@pytest.fixture
def mock_pool():
    """Mock asyncpg connection pool."""
    pool = AsyncMock()
    connection = AsyncMock()
    pool.acquire.return_value.__aenter__.return_value = connection
    pool.acquire.return_value.__aexit__.return_value = None
    return pool, connection


@pytest.fixture
def sample_rules() -> List[Dict[str, Any]]:
    """Sample rule data for testing."""
    return [
        {
            "id": 1,
            "name": "null_check_customer_id",
            "description": "Check for null customer IDs",
            "rule_type": "null_check",
            "table_name": "customers",
            "column_name": "customer_id",
            "is_active": True,
            "custom_sql": None
        },
        {
            "id": 2,
            "name": "unique_email",
            "description": "Ensure unique email addresses",
            "rule_type": "unique_check",
            "table_name": "customers",
            "column_name": "email",
            "is_active": True,
            "custom_sql": None
        }
    ]


@pytest.fixture
def sample_custom_rule() -> Dict[str, Any]:
    """Sample custom SQL rule for testing."""
    return {
        "name": "custom_validation",
        "description": "Custom SQL validation rule",
        "table_name": "orders",
        "custom_sql": "SELECT * FROM orders WHERE total < 0"
    }


class TestDataQualityRoutes:
    """Test suite for data quality routes."""

    @pytest.mark.asyncio
    async def test_get_rules_success(self, mock_pool, sample_rules):
        """Test GET /data-quality/rules returns list of rules."""
        pool, connection = mock_pool
        connection.fetch.return_value = [
            {**rule, "created_at": "2025-01-01", "updated_at": "2025-01-01"}
            for rule in sample_rules
        ]

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.get("/data-quality/rules")

        assert response.status_code == 200
        data = response.json()
        assert "rules" in data
        assert len(data["rules"]) == 2

    @pytest.mark.asyncio
    async def test_get_rules_empty(self, mock_pool):
        """Test GET /data-quality/rules with no rules."""
        pool, connection = mock_pool
        connection.fetch.return_value = []

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.get("/data-quality/rules")

        assert response.status_code == 200
        data = response.json()
        assert data["rules"] == []

    @pytest.mark.asyncio
    async def test_get_rules_active_only(self, mock_pool, sample_rules):
        """Test GET /data-quality/rules with active_only filter."""
        pool, connection = mock_pool
        active_rules = [r for r in sample_rules if r["is_active"]]
        connection.fetch.return_value = active_rules

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.get("/data-quality/rules?active_only=true")

        assert response.status_code == 200

    @pytest.mark.asyncio
    async def test_create_rule_success(self, mock_pool):
        """Test POST /data-quality/rules creates a new rule."""
        pool, connection = mock_pool
        connection.fetchrow.return_value = {
            "id": 3,
            "name": "new_rule",
            "description": "New rule description",
            "rule_type": "null_check",
            "table_name": "products",
            "column_name": "product_id",
            "is_active": True,
            "custom_sql": None,
            "created_at": "2025-01-01",
            "updated_at": "2025-01-01"
        }

        rule_data = {
            "name": "new_rule",
            "description": "New rule description",
            "rule_type": "null_check",
            "table_name": "products",
            "column_name": "product_id"
        }

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.post("/data-quality/rules", json=rule_data)

        assert response.status_code == 201

    @pytest.mark.asyncio
    async def test_create_rule_invalid_table(self, mock_pool):
        """Test POST /data-quality/rules with invalid table name."""
        pool, connection = mock_pool

        rule_data = {
            "name": "invalid_rule",
            "description": "Rule for invalid table",
            "rule_type": "null_check",
            "table_name": "nonexistent_table",
            "column_name": "id"
        }

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.post("/data-quality/rules", json=rule_data)

        # Should return 400 or 404 for invalid table
        assert response.status_code in [400, 404, 422]

    @pytest.mark.asyncio
    async def test_create_custom_rule_success(self, mock_pool, sample_custom_rule):
        """Test POST /data-quality/rules/custom creates custom SQL rule."""
        pool, connection = mock_pool
        connection.fetchrow.return_value = {
            "id": 4,
            **sample_custom_rule,
            "rule_type": "custom_sql",
            "column_name": None,
            "is_active": True,
            "created_at": "2025-01-01",
            "updated_at": "2025-01-01"
        }

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.post("/data-quality/rules/custom", json=sample_custom_rule)

        assert response.status_code == 201

    @pytest.mark.asyncio
    async def test_create_custom_rule_invalid_sql(self, mock_pool):
        """Test POST /data-quality/rules/custom rejects non-SELECT SQL."""
        pool, connection = mock_pool

        invalid_rule = {
            "name": "malicious_rule",
            "description": "Attempting SQL injection",
            "table_name": "orders",
            "custom_sql": "DELETE FROM orders WHERE 1=1"
        }

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.post("/data-quality/rules/custom", json=invalid_rule)

        assert response.status_code == 400
        assert "SELECT" in response.json()["detail"]

    @pytest.mark.asyncio
    async def test_get_rule_by_id_success(self, mock_pool, sample_rules):
        """Test GET /data-quality/rules/{id} returns specific rule."""
        pool, connection = mock_pool
        connection.fetchrow.return_value = {
            **sample_rules[0],
            "created_at": "2025-01-01",
            "updated_at": "2025-01-01"
        }

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.get("/data-quality/rules/1")

        assert response.status_code == 200
        data = response.json()
        assert data["id"] == 1

    @pytest.mark.asyncio
    async def test_get_rule_by_id_not_found(self, mock_pool):
        """Test GET /data-quality/rules/{id} returns 404 for nonexistent rule."""
        pool, connection = mock_pool
        connection.fetchrow.return_value = None

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.get("/data-quality/rules/999")

        assert response.status_code == 404

    @pytest.mark.asyncio
    async def test_update_rule_success(self, mock_pool, sample_rules):
        """Test PUT /data-quality/rules/{id} updates a rule."""
        pool, connection = mock_pool
        updated_rule = {**sample_rules[0], "name": "updated_rule_name"}
        connection.fetchrow.return_value = {
            **updated_rule,
            "created_at": "2025-01-01",
            "updated_at": "2025-01-02"
        }

        update_data = {"name": "updated_rule_name"}

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.put("/data-quality/rules/1", json=update_data)

        assert response.status_code == 200

    @pytest.mark.asyncio
    async def test_delete_rule_success(self, mock_pool):
        """Test DELETE /data-quality/rules/{id} removes a rule."""
        pool, connection = mock_pool
        connection.execute.return_value = "DELETE 1"

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.delete("/data-quality/rules/1")

        assert response.status_code == 204

    @pytest.mark.asyncio
    async def test_toggle_rule_success(self, mock_pool, sample_rules):
        """Test PATCH /data-quality/rules/{id}/toggle toggles active status."""
        pool, connection = mock_pool
        toggled_rule = {**sample_rules[0], "is_active": False}
        connection.fetchrow.return_value = {
            **toggled_rule,
            "created_at": "2025-01-01",
            "updated_at": "2025-01-02"
        }

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.patch("/data-quality/rules/1/toggle")

        assert response.status_code == 200
        data = response.json()
        assert data["is_active"] == False

    @pytest.mark.asyncio
    async def test_suggest_rules_success(self, mock_pool):
        """Test GET /data-quality/rules/suggest returns rule suggestions."""
        pool, connection = mock_pool
        connection.fetch.return_value = [
            {
                "table_name": "customers",
                "column_name": "email",
                "data_type": "varchar",
                "null_count": 5,
                "distinct_count": 95,
                "row_count": 100
            }
        ]

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.get("/data-quality/rules/suggest")

        assert response.status_code == 200
        data = response.json()
        assert "suggestions" in data

    @pytest.mark.asyncio
    async def test_execute_rule_success(self, mock_pool, sample_rules):
        """Test POST /data-quality/rules/{id}/execute runs a rule."""
        pool, connection = mock_pool
        # First call returns the rule
        connection.fetchrow.return_value = {
            **sample_rules[0],
            "created_at": "2025-01-01",
            "updated_at": "2025-01-01"
        }
        # Execution returns violation count
        connection.fetchval.return_value = 5

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.post("/data-quality/rules/1/execute")

        assert response.status_code == 200
        data = response.json()
        assert "violations" in data or "result" in data


class TestDataQualityEdgeCases:
    """Edge case and error handling tests."""

    @pytest.mark.asyncio
    async def test_create_rule_missing_fields(self, mock_pool):
        """Test POST /data-quality/rules with missing required fields."""
        pool, connection = mock_pool

        incomplete_rule = {"name": "incomplete"}

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.post("/data-quality/rules", json=incomplete_rule)

        assert response.status_code == 422  # Validation error

    @pytest.mark.asyncio
    async def test_update_nonexistent_rule(self, mock_pool):
        """Test PUT /data-quality/rules/{id} for nonexistent rule."""
        pool, connection = mock_pool
        connection.fetchrow.return_value = None

        update_data = {"name": "updated_name"}

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.put("/data-quality/rules/999", json=update_data)

        assert response.status_code == 404

    @pytest.mark.asyncio
    async def test_delete_nonexistent_rule(self, mock_pool):
        """Test DELETE /data-quality/rules/{id} for nonexistent rule."""
        pool, connection = mock_pool
        connection.execute.return_value = "DELETE 0"

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.delete("/data-quality/rules/999")

        assert response.status_code in [204, 404]

    @pytest.mark.asyncio
    async def test_custom_rule_with_drop_statement(self, mock_pool):
        """Test custom rule rejects DROP statements."""
        pool, connection = mock_pool

        malicious_rule = {
            "name": "drop_attack",
            "description": "Attempting to drop table",
            "table_name": "orders",
            "custom_sql": "DROP TABLE orders; SELECT 1"
        }

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.post("/data-quality/rules/custom", json=malicious_rule)

        assert response.status_code == 400

    @pytest.mark.asyncio
    async def test_custom_rule_with_truncate_statement(self, mock_pool):
        """Test custom rule rejects TRUNCATE statements."""
        pool, connection = mock_pool

        malicious_rule = {
            "name": "truncate_attack",
            "description": "Attempting to truncate table",
            "table_name": "orders",
            "custom_sql": "TRUNCATE TABLE orders"
        }

        with patch("app.services.data_quality_rules.get_pool", return_value=pool):
            from app.main import app
            transport = ASGITransport(app=app)
            async with AsyncClient(transport=transport, base_url=TEST_BASE_URL) as client:
                response = await client.post("/data-quality/rules/custom", json=malicious_rule)

        assert response.status_code == 400
