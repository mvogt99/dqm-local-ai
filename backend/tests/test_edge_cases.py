"""
Edge Case Tests for DQM Application
Generated by RTX 3050 (Qwen2.5-Coder-7B-Instruct)
"""
import pytest
import asyncio
from httpx import AsyncClient
from app.main import app


@pytest.fixture
async def client():
    """Create async test client."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        yield client


@pytest.mark.asyncio
async def test_empty_table_name(client):
    """Test that empty table names are rejected."""
    response = await client.get("/api/profile/")
    assert response.status_code in [404, 400, 422]


@pytest.mark.asyncio
async def test_very_long_table_name(client):
    """Test that very long table names are rejected."""
    long_name = "a" * 1000
    response = await client.get(f"/api/profile/{long_name}")
    assert response.status_code == 400


@pytest.mark.asyncio
async def test_special_characters_in_table_name(client):
    """Test that special characters in table names are rejected."""
    special_chars = "!@#$%^&*()_+"
    response = await client.get(f"/api/profile/{special_chars}")
    assert response.status_code == 400


@pytest.mark.asyncio
async def test_sql_injection_attempt(client):
    """Test that SQL injection attempts are blocked."""
    sql_injection = "users; DROP TABLE users;--"
    response = await client.get(f"/api/profile/{sql_injection}")
    assert response.status_code == 400
    assert "whitelist" in response.text.lower() or "not allowed" in response.text.lower()


@pytest.mark.asyncio
async def test_empty_rule_creation(client):
    """Test that empty rule creation is rejected."""
    response = await client.post("/api/rules", json={
        "name": "",
        "description": "",
        "condition": ""
    })
    assert response.status_code in [400, 422]


@pytest.mark.asyncio
async def test_invalid_severity_level(client):
    """Test that invalid severity levels are rejected."""
    response = await client.post("/api/rules", json={
        "name": "test_rule",
        "description": "Test",
        "condition": "x > 0",
        "severity": "invalid_severity"
    })
    # Should either reject or use default
    assert response.status_code in [201, 400, 422]


@pytest.mark.asyncio
async def test_non_existent_rule_id(client):
    """Test that non-existent rule IDs return 404."""
    response = await client.get("/api/rules/99999")
    assert response.status_code == 404


@pytest.mark.asyncio
async def test_delete_non_existent_rule(client):
    """Test deleting a non-existent rule."""
    response = await client.delete("/api/rules/99999")
    assert response.status_code in [204, 404]


@pytest.mark.asyncio
async def test_unicode_in_table_name(client):
    """Test that unicode characters are handled properly."""
    unicode_name = "表_データ"
    response = await client.get(f"/api/profile/{unicode_name}")
    assert response.status_code == 400


@pytest.mark.asyncio
async def test_path_traversal_attempt(client):
    """Test that path traversal attempts are blocked."""
    path_traversal = "../../../etc/passwd"
    response = await client.get(f"/api/profile/{path_traversal}")
    assert response.status_code == 400


@pytest.mark.asyncio
async def test_concurrent_rule_creation(client):
    """Test handling of concurrent requests."""
    async def create_rule(i):
        return await client.post("/api/rules", json={
            "name": f"concurrent_rule_{i}",
            "description": "Concurrent test",
            "condition": f"x > {i}"
        })

    # Create 5 concurrent requests
    tasks = [create_rule(i) for i in range(5)]
    responses = await asyncio.gather(*tasks, return_exceptions=True)

    # All should succeed or fail gracefully
    for response in responses:
        if not isinstance(response, Exception):
            assert response.status_code in [201, 429]  # Created or rate limited
