"""
Middleware Tests for DQM Application
Generated by RTX 3050 (Qwen2.5-Coder-7B-Instruct)
"""
import pytest
from unittest.mock import patch, MagicMock
from httpx import AsyncClient
from app.main import app
from app.middleware.rate_limiting import RateLimiter, RateLimitExceeded
from app.middleware.auth import verify_api_key, load_valid_api_keys
from app.middleware.cors_config import get_allowed_origins, validate_origin


class TestRateLimiting:
    """Tests for rate limiting middleware."""

    def test_rate_limiter_allows_initial_requests(self):
        """Test that initial requests are allowed."""
        limiter = RateLimiter(limit=5, period=60)
        for _ in range(5):
            assert limiter.is_allowed("127.0.0.1")

    def test_rate_limiter_blocks_after_limit(self):
        """Test that requests are blocked after limit is exceeded."""
        limiter = RateLimiter(limit=3, period=60)
        for _ in range(3):
            limiter.is_allowed("127.0.0.1")
        assert not limiter.is_allowed("127.0.0.1")

    def test_rate_limiter_different_ips(self):
        """Test that different IPs have separate limits."""
        limiter = RateLimiter(limit=2, period=60)
        limiter.is_allowed("127.0.0.1")
        limiter.is_allowed("127.0.0.1")
        assert not limiter.is_allowed("127.0.0.1")
        assert limiter.is_allowed("192.168.1.1")

    def test_rate_limiter_cleanup(self):
        """Test cleanup of expired entries."""
        limiter = RateLimiter(limit=5, period=1)
        limiter.requests["old_ip"] = (5, 0)  # Expired entry
        limiter.cleanup()
        assert "old_ip" not in limiter.requests


class TestCORSConfiguration:
    """Tests for CORS configuration."""

    @patch.dict('os.environ', {'ENVIRONMENT': 'development'})
    def test_development_origins(self):
        """Test that development mode allows multiple origins."""
        origins = get_allowed_origins()
        assert "http://localhost" in origins or len(origins) > 0

    @patch.dict('os.environ', {'ENVIRONMENT': 'production', 'ALLOWED_ORIGIN': 'https://example.com'})
    def test_production_origin(self):
        """Test that production mode uses specific origin."""
        origins = get_allowed_origins()
        assert "https://example.com" in origins

    def test_validate_origin_allowed(self):
        """Test origin validation for allowed origins."""
        with patch('app.middleware.cors_config.get_allowed_origins', return_value=['http://localhost']):
            assert validate_origin('http://localhost')

    def test_validate_origin_rejected(self):
        """Test origin validation for rejected origins."""
        with patch('app.middleware.cors_config.get_allowed_origins', return_value=['http://localhost']):
            assert not validate_origin('http://malicious.com')


class TestAuthentication:
    """Tests for API authentication."""

    @patch.dict('os.environ', {'VALID_API_KEYS': 'key1,key2,key3'})
    def test_load_valid_api_keys(self):
        """Test loading valid API keys from environment."""
        keys = load_valid_api_keys()
        assert 'key1' in keys
        assert 'key2' in keys
        assert 'key3' in keys

    @patch.dict('os.environ', {'VALID_API_KEYS': ''})
    def test_empty_api_keys(self):
        """Test handling of empty API keys (development mode)."""
        keys = load_valid_api_keys()
        assert len(keys) == 0

    @patch('app.middleware.auth.load_valid_api_keys', return_value={'valid_key'})
    def test_verify_valid_api_key(self, mock_keys):
        """Test verification of valid API key."""
        result = verify_api_key('valid_key')
        assert result is True

    @patch('app.middleware.auth.load_valid_api_keys', return_value={'valid_key'})
    def test_verify_invalid_api_key(self, mock_keys):
        """Test rejection of invalid API key."""
        from fastapi import HTTPException
        with pytest.raises(HTTPException) as exc_info:
            verify_api_key('invalid_key')
        assert exc_info.value.status_code == 401


@pytest.fixture
async def client():
    """Create async test client."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        yield client


@pytest.mark.asyncio
async def test_rate_limit_response(client):
    """Integration test for rate limiting response."""
    # This would need the middleware to be properly configured
    # For unit testing, we test the RateLimiter class directly
    pass


@pytest.mark.asyncio
async def test_health_endpoint(client):
    """Test health check endpoint."""
    response = await client.get("/health")
    # Should return 200 if endpoint exists
    assert response.status_code in [200, 404]
