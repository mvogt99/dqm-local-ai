"""
Phase 1 Services Test Suite
Generated by: RTX 5090 (test plan), RTX 3050 (implementation), Expert AI (enhancement)
Following TDD principles
"""
import pytest
from datetime import datetime
from unittest.mock import AsyncMock, MagicMock

# Import services
import sys
sys.path.insert(0, '/mnt/e/source/applications/dqm-local-ai/backend')


class TestAIAnalysisService:
    """Test suite for AI Analysis Service."""

    @pytest.fixture
    def service(self):
        from app.services.ai_analysis_service import AIAnalysisService
        return AIAnalysisService(pool=None)

    @pytest.mark.asyncio
    async def test_analyze_profile_returns_insights(self, service):
        """Test that analyze_profile returns insights dict."""
        profile_data = {
            "table_name": "test_table",
            "columns": [
                {"column_name": "id", "null_percentage": 0, "distinct_percentage": 100}
            ],
            "row_count": 100
        }
        result = await service.analyze_profile(profile_data)
        assert "insights" in result
        assert "table_name" in result
        assert result["table_name"] == "test_table"

    @pytest.mark.asyncio
    async def test_analyze_profile_detects_high_nulls(self, service):
        """Test detection of high null percentage."""
        profile_data = {
            "table_name": "test_table",
            "columns": [
                {"column_name": "optional_field", "null_percentage": 85, "distinct_percentage": 10}
            ],
            "row_count": 1000
        }
        result = await service.analyze_profile(profile_data)
        assert len(result["insights"]) > 0
        assert any("null" in i["description"].lower() for i in result["insights"])

    @pytest.mark.asyncio
    async def test_detect_anomalies_empty_stats(self, service):
        """Test anomaly detection with empty stats."""
        result = await service.detect_anomalies({})
        assert result == []

    @pytest.mark.asyncio
    async def test_detect_anomalies_large_table(self, service):
        """Test anomaly detection for large table."""
        table_stats = {
            "huge_table": {"row_count": 15_000_000, "total_columns": 10}
        }
        result = await service.detect_anomalies(table_stats)
        assert len(result) > 0
        assert any("large" in str(a).lower() or "performance" in str(a).lower() for a in result)


class TestReportService:
    """Test suite for Report Service."""

    @pytest.fixture
    def service(self):
        from app.services.report_service import ReportService
        return ReportService(pool=None)

    @pytest.mark.asyncio
    async def test_generate_json_report(self, service):
        """Test JSON report generation."""
        data = {"test_key": "test_value"}
        result = await service.generate_report("test_report", data, "json")
        assert result["format"] == "json"
        assert "content" in result

    @pytest.mark.asyncio
    async def test_generate_html_report(self, service):
        """Test HTML report generation."""
        data = {"test_key": "test_value"}
        result = await service.generate_report("test_report", data, "html")
        assert result["format"] == "html"
        assert "<html>" in result["content"]

    def test_get_templates_returns_list(self, service):
        """Test that templates are returned as list."""
        templates = service.get_report_templates()
        assert isinstance(templates, list)
        assert len(templates) > 0
        assert all("template_id" in t for t in templates)

    @pytest.mark.asyncio
    async def test_generate_report_invalid_format(self, service):
        """Test that invalid format raises error."""
        with pytest.raises(ValueError):
            await service.generate_report("test", {}, "pdf")


class TestDataLineageService:
    """Test suite for Data Lineage Service."""

    @pytest.fixture
    def mock_pool(self):
        pool = AsyncMock()
        conn = AsyncMock()
        pool.acquire.return_value.__aenter__.return_value = conn
        return pool, conn

    @pytest.mark.asyncio
    async def test_track_lineage_success(self, mock_pool):
        """Test successful lineage tracking."""
        pool, conn = mock_pool
        conn.fetchrow.return_value = {"id": 1}
        
        from app.services.lineage_service import DataLineageService
        service = DataLineageService(pool)
        
        result = await service.track_lineage(
            source_table="source",
            source_column="col1",
            target_table="target",
            target_column="col2"
        )
        assert result == 1

    @pytest.mark.asyncio
    async def test_get_table_lineage(self, mock_pool):
        """Test retrieving table lineage."""
        pool, conn = mock_pool
        conn.fetch.return_value = [
            {"source_table": "a", "target_table": "b"}
        ]
        
        from app.services.lineage_service import DataLineageService
        service = DataLineageService(pool)
        
        result = await service.get_table_lineage("test_table")
        assert isinstance(result, list)

    @pytest.mark.asyncio
    async def test_impact_analysis(self, mock_pool):
        """Test impact analysis."""
        pool, conn = mock_pool
        conn.fetch.return_value = [
            {"target_table": "downstream1", "target_column": "col", "transformation_type": "direct"}
        ]
        
        from app.services.lineage_service import DataLineageService
        service = DataLineageService(pool)
        
        result = await service.get_impact_analysis("source_table")
        assert "affected_tables" in result
        assert "source_table" in result
