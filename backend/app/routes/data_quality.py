"""
Data Quality Routes - Domain-Separated with Feature Parity
Generated by RTX 5090 (Qwen2.5-Coder-32B-Instruct-AWQ)
Fixed by RTX 3050 (Qwen2.5-Coder-7B) - Added table_name endpoint support
Enhanced by Expert AI (Claude Opus 4.5) - Added custom rules, CRUD operations, and feature parity

V74: Feature parity with dqm-expert-ai
- GET /rules/suggest - Suggest rules from stored profiling results
- POST /rules/custom - Create custom user-defined rules
- PUT /rules/{rule_id} - Update existing rules
- DELETE /rules/{rule_id} - Delete rules
- PATCH /rules/{rule_id}/toggle - Activate/deactivate rules
"""
from fastapi import APIRouter, HTTPException, Body, Query
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from enum import Enum

from app.services.data_quality_rules import DataQualityRulesService
from app.services.data_profiling_service import get_profiling_service
from app.config import settings


class RuleType(str, Enum):
    """Supported data quality rule types."""
    NULL_CHECK = "null_check"
    NOT_NULL = "not_null"
    UNIQUE_CHECK = "unique_check"
    RANGE_CHECK = "range_check"
    PATTERN_CHECK = "pattern_check"
    FOREIGN_KEY_CHECK = "foreign_key_check"
    CUSTOM_SQL = "custom_sql"


class Severity(str, Enum):
    """Rule severity levels."""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


class SuggestRulesRequest(BaseModel):
    """Request model for suggesting rules by table name."""
    table_name: str


class RuleCreate(BaseModel):
    """Request model for creating a data quality rule."""
    name: str = Field(..., min_length=1, max_length=255)
    table: str = Field(..., min_length=1, max_length=255)
    column: str = Field(..., min_length=1, max_length=255)
    rule_type: str = Field(..., description="Rule type (null_check, unique_check, etc.)")
    definition: str = Field(..., description="SQL query or rule definition")
    severity: str = Field(default="warning", description="Rule severity (info, warning, critical)")


class CustomRuleCreate(BaseModel):
    """Request model for creating a custom SQL rule."""
    name: str = Field(..., min_length=1, max_length=255, description="Rule name")
    table: str = Field(..., min_length=1, max_length=255, description="Target table")
    column: str = Field(..., min_length=1, max_length=255, description="Target column")
    custom_sql: str = Field(..., min_length=10, description="Custom SQL query that returns failing rows")
    description: Optional[str] = Field(None, description="Human-readable description")
    severity: str = Field(default="warning", description="Rule severity")
    threshold: Optional[float] = Field(None, ge=0, le=100, description="Failure threshold percentage")


class RuleUpdate(BaseModel):
    """Request model for updating a rule."""
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    definition: Optional[str] = None
    severity: Optional[str] = None
    is_active: Optional[bool] = None


class RuleResponse(BaseModel):
    """Response model for a data quality rule."""
    id: Optional[int] = None
    name: str
    table: str
    column: str
    rule_type: str
    definition: str
    severity: str
    is_active: bool = True
    created_at: Optional[str] = None


class ExecutionResult(BaseModel):
    """Response model for rule execution result."""
    rule_id: int
    passed: bool
    total_count: int
    failed_count: int
    pass_rate: float
    failures: List[Any]


router = APIRouter(
    prefix="/data-quality",
    tags=["Data Quality"]
)


def get_service() -> DataQualityRulesService:
    """Get the data quality rules service instance."""
    return DataQualityRulesService(settings.DATABASE_URL)


# ============================================================================
# RULE LISTING AND RETRIEVAL
# ============================================================================

@router.get("/rules", response_model=List[RuleResponse])
async def list_rules(
    active_only: bool = Query(True, description="Filter to active rules only")
):
    """
    List all data quality rules.

    Returns a list of data quality rules, optionally filtered by active status.
    """
    try:
        service = get_service()
        rules = await service.get_all_rules(active_only=active_only)
        return [RuleResponse(**r) if isinstance(r, dict) else r for r in rules]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to list rules: {str(e)}")


# IMPORTANT: /rules/suggest must be defined BEFORE /rules/{rule_id}
# to prevent "suggest" from being parsed as an integer rule_id
@router.get("/rules/suggest")
async def suggest_rules_from_stored_profiles(
    table_name: Optional[str] = Query(None, description="Filter suggestions by table")
):
    """
    Suggest data quality rules based on stored profiling results.

    This endpoint uses previously stored profiling results to generate
    intelligent rule suggestions. Matches expert-ai feature parity.
    """
    try:
        profiling_service = await get_profiling_service()
        service = get_service()

        # Get stored profiling results
        stored_results = await profiling_service.get_stored_results(
            table_name=table_name,
            limit=50
        )

        if not stored_results:
            return {
                "suggestions": [],
                "message": "No stored profiling results found. Run profiling first."
            }

        # Convert stored results to format expected by suggest_rules
        profile_data = []
        for result in stored_results:
            profile_data.append({
                'table': result.get('table_name', ''),
                'column': result.get('column_name', ''),
                'null_percentage': result.get('null_percent', 0) / 100 if result.get('null_percent') else 0,
                'unique_count': result.get('unique_count', 0),
                'data_type': result.get('data_type', ''),
                'min_value': result.get('min_value'),
                'max_value': result.get('max_value'),
                'sample_values': result.get('sample_values', [])
            })

        suggestions = await service.suggest_rules(profile_data)

        return {
            "suggestions": suggestions,
            "source": "stored_profiling_results",
            "profiles_analyzed": len(profile_data),
            "table_filter": table_name
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to suggest rules: {str(e)}")


@router.get("/rules/{rule_id}", response_model=RuleResponse)
async def get_rule(rule_id: int):
    """
    Get a specific data quality rule.

    Returns details of a single rule by ID.
    """
    try:
        service = get_service()
        rule = await service.get_rule_by_id(rule_id)
        if not rule:
            raise HTTPException(status_code=404, detail="Rule not found")
        return RuleResponse(**rule)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get rule: {str(e)}")


# ============================================================================
# RULE CREATION
# ============================================================================

@router.post("/rules", response_model=dict, status_code=201)
async def create_rule(rule: RuleCreate):
    """
    Create a new data quality rule.

    Creates a rule that can be executed against the database.
    """
    try:
        service = get_service()
        rule_id = await service.create_rule(
            name=rule.name,
            table=rule.table,
            column=rule.column,
            rule_type=rule.rule_type,
            definition=rule.definition,
            severity=rule.severity
        )
        return {"message": "Rule created successfully", "id": rule_id, "name": rule.name}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create rule: {str(e)}")


@router.post("/rules/custom", response_model=dict, status_code=201)
async def create_custom_rule(rule: CustomRuleCreate):
    """
    Create a custom SQL-based data quality rule.

    Allows users to define their own SQL queries for custom validation logic.
    The SQL query should return rows that FAIL the quality check.

    Example custom_sql:
    - "SELECT * FROM orders WHERE total_amount < 0"
    - "SELECT * FROM customers WHERE email NOT LIKE '%@%.%'"
    """
    try:
        service = get_service()

        # Validate the custom SQL (basic security check)
        sql_lower = rule.custom_sql.lower().strip()
        if not sql_lower.startswith('select'):
            raise HTTPException(
                status_code=400,
                detail="Custom SQL must be a SELECT statement"
            )
        if any(kw in sql_lower for kw in ['insert', 'update', 'delete', 'drop', 'truncate', 'alter']):
            raise HTTPException(
                status_code=400,
                detail="Custom SQL cannot contain write operations"
            )

        rule_id = await service.create_custom_rule(
            name=rule.name,
            table=rule.table,
            column=rule.column,
            custom_sql=rule.custom_sql,
            description=rule.description,
            severity=rule.severity,
            threshold=rule.threshold
        )

        return {
            "message": "Custom rule created successfully",
            "id": rule_id,
            "name": rule.name,
            "type": "custom_sql"
        }
    except HTTPException:
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create custom rule: {str(e)}")


# ============================================================================
# RULE MODIFICATION
# ============================================================================

@router.put("/rules/{rule_id}", response_model=dict)
async def update_rule(rule_id: int, rule: RuleUpdate):
    """
    Update an existing data quality rule.

    Allows partial updates - only provided fields will be changed.
    """
    try:
        service = get_service()

        # Check rule exists
        existing = await service.get_rule_by_id(rule_id)
        if not existing:
            raise HTTPException(status_code=404, detail="Rule not found")

        # Build update dict with only provided fields
        update_data = {k: v for k, v in rule.dict().items() if v is not None}
        if not update_data:
            raise HTTPException(status_code=400, detail="No fields to update")

        await service.update_rule(rule_id, **update_data)
        return {"message": "Rule updated successfully", "id": rule_id}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to update rule: {str(e)}")


@router.delete("/rules/{rule_id}", status_code=204)
async def delete_rule(rule_id: int):
    """
    Delete a data quality rule.

    Permanently removes the rule and its execution history.
    """
    try:
        service = get_service()

        # Check rule exists
        existing = await service.get_rule_by_id(rule_id)
        if not existing:
            raise HTTPException(status_code=404, detail="Rule not found")

        await service.delete_rule(rule_id)
        return None
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to delete rule: {str(e)}")


@router.patch("/rules/{rule_id}/toggle", response_model=dict)
async def toggle_rule_active(rule_id: int):
    """
    Toggle the active status of a rule.

    Activates an inactive rule or deactivates an active rule.
    """
    try:
        service = get_service()

        # Check rule exists
        existing = await service.get_rule_by_id(rule_id)
        if not existing:
            raise HTTPException(status_code=404, detail="Rule not found")

        current_status = existing.get('is_active', True)
        new_status = not current_status

        await service.update_rule(rule_id, is_active=new_status)
        return {
            "message": f"Rule {'activated' if new_status else 'deactivated'} successfully",
            "id": rule_id,
            "is_active": new_status
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to toggle rule: {str(e)}")


# ============================================================================
# RULE EXECUTION
# ============================================================================

@router.post("/rules/{rule_id}/execute")
async def execute_rule(rule_id: int):
    """
    Execute a data quality rule.

    Runs the rule against the database and returns pass/fail status with details.
    """
    try:
        service = get_service()
        result = await service.execute_rule(rule_id)

        return {
            "rule_id": rule_id,
            "executed": True,
            "passed": result.get('passed', False),
            "total_count": result.get('total_count', 0),
            "failed_count": result.get('failed_count', 0),
            "pass_rate": result.get('pass_rate', 0),
            "failure_samples": result.get('failure_samples', [])[:10]
        }
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to execute rule: {str(e)}")


# ============================================================================
# LEGACY ENDPOINTS (maintained for backwards compatibility)
# ============================================================================

@router.post("/suggest")
async def suggest_rules_by_table(request: SuggestRulesRequest = Body(...)):
    """
    Suggest data quality rules based on table name.

    Fetches profile data internally and generates rule suggestions.
    Legacy endpoint - consider using GET /rules/suggest for stored results.
    """
    try:
        # Get profiling service and fetch profile
        profiling_service = await get_profiling_service()
        profile = await profiling_service.profile_table(request.table_name)

        # Convert profile to format expected by suggest_rules
        profile_data = []
        for col in profile.columns:
            profile_data.append({
                'table': request.table_name,
                'column': col.column_name,
                'null_percentage': col.null_percent / 100 if col.null_percent else 0,
                'unique_count': col.unique_count,
                'data_type': col.data_type
            })

        # Get rule suggestions
        service = get_service()
        suggestions = await service.suggest_rules(profile_data)

        return {
            "table_name": request.table_name,
            "rules": suggestions,
            "profile_summary": {
                "row_count": profile.row_count,
                "column_count": profile.column_count
            }
        }
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to suggest rules: {str(e)}")


@router.get("/results")
async def get_results(
    rule_id: Optional[int] = Query(None, description="Filter by rule ID"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum results to return")
):
    """
    Get rule execution results.

    V85: Fixed to return array directly for frontend compatibility.
    Returns historical execution results, optionally filtered by rule ID.
    """
    try:
        service = get_service()
        results = await service.get_execution_results(rule_id=rule_id, limit=limit)
        return results  # Return array directly for frontend compatibility
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get results: {str(e)}")
