"""
Database Connection Manager Routes
V79 Enhancement: Dynamic database connection switching
Generated by RTX 3050 (Qwen2.5-Coder-7B-Instruct)
Architecture by RTX 5090 (Qwen2.5-Coder-32B-Instruct-AWQ)
"""
"""
V82 Fix: Removed broken import (app.config.database doesn't exist)
The get_pool was never used - this file is self-contained.
"""
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List, Optional, Dict
import asyncpg
import logging

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/connections",
    tags=["Database Connections"]
)


# Pydantic models
class ConnectionConfig(BaseModel):
    """Database connection configuration."""
    name: str
    db_type: str = "postgresql"  # postgresql or azure
    host: str
    port: int = 5432
    database: str
    username: str
    password: str
    ssl_mode: Optional[str] = None


class ConnectionTestRequest(BaseModel):
    """Request to test a database connection."""
    host: str
    port: int = 5432
    database: str
    username: str
    password: str
    db_type: str = "postgresql"


class ConnectionStatus(BaseModel):
    """Status of a database connection."""
    name: str
    status: str
    message: Optional[str] = None
    is_active: bool = False


# In-memory storage for saved connections
_saved_connections: Dict[str, ConnectionConfig] = {}
_active_connection: Optional[str] = None


@router.get("", response_model=List[ConnectionStatus])
async def list_connections():
    """
    List all saved database connections.

    Returns status for each saved connection including which is active.
    """
    global _active_connection
    connections = []

    for name, config in _saved_connections.items():
        connections.append(ConnectionStatus(
            name=name,
            status="saved",
            is_active=(name == _active_connection)
        ))

    # Add default connection
    connections.insert(0, ConnectionStatus(
        name="default",
        status="active" if _active_connection is None else "available",
        message="Default Northwind database",
        is_active=(_active_connection is None)
    ))

    return connections


@router.post("", response_model=ConnectionStatus)
async def save_connection(config: ConnectionConfig):
    """
    Save a new database connection configuration.

    Does not switch to the connection - use /switch endpoint for that.
    """
    global _saved_connections

    if config.name == "default":
        raise HTTPException(status_code=400, detail="Cannot override default connection")

    _saved_connections[config.name] = config
    logger.info(f"Saved connection config: {config.name}")

    return ConnectionStatus(
        name=config.name,
        status="saved",
        message=f"Connection '{config.name}' saved successfully"
    )


@router.post("/test", response_model=ConnectionStatus)
async def test_connection(request: ConnectionTestRequest):
    """
    Test a database connection without saving or switching.

    Attempts to connect and run a simple query to verify connectivity.
    """
    try:
        # Build connection string
        if request.db_type == "azure":
            dsn = f"postgresql://{request.username}:{request.password}@{request.host}:{request.port}/{request.database}?sslmode=require"
        else:
            dsn = f"postgresql://{request.username}:{request.password}@{request.host}:{request.port}/{request.database}"

        # Test connection
        conn = await asyncpg.connect(dsn, timeout=10)
        try:
            # Run simple query
            result = await conn.fetchval("SELECT 1")
            if result == 1:
                return ConnectionStatus(
                    name="test",
                    status="success",
                    message=f"Successfully connected to {request.host}:{request.port}/{request.database}"
                )
        finally:
            await conn.close()

    except asyncpg.InvalidCatalogNameError:
        raise HTTPException(status_code=400, detail=f"Database '{request.database}' does not exist")
    except asyncpg.InvalidPasswordError:
        raise HTTPException(status_code=401, detail="Invalid username or password")
    except asyncpg.PostgresConnectionError as e:
        raise HTTPException(status_code=503, detail=f"Connection failed: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Connection test failed: {str(e)}")


@router.post("/switch", response_model=ConnectionStatus)
async def switch_connection(name: str):
    """
    Switch to a different database connection.

    Requires the connection to be saved first (or 'default' for original).
    Note: Full runtime switching requires server restart for pool recreation.
    """
    global _active_connection, _saved_connections

    if name == "default":
        # Reset to default connection
        _active_connection = None
        logger.info("Switched to default connection (requires restart for full effect)")
        return ConnectionStatus(
            name="default",
            status="active",
            message="Switched to default Northwind database. Restart server to apply.",
            is_active=True
        )

    if name not in _saved_connections:
        raise HTTPException(status_code=404, detail=f"Connection '{name}' not found")

    config = _saved_connections[name]

    # Test the connection first
    try:
        if config.db_type == "azure":
            dsn = f"postgresql://{config.username}:{config.password}@{config.host}:{config.port}/{config.database}?sslmode=require"
        else:
            dsn = f"postgresql://{config.username}:{config.password}@{config.host}:{config.port}/{config.database}"

        conn = await asyncpg.connect(dsn, timeout=10)
        await conn.close()

        _active_connection = name
        logger.info(f"Switched to connection: {name}")

        return ConnectionStatus(
            name=name,
            status="active",
            message=f"Switched to '{name}'. Restart server to apply full connection.",
            is_active=True
        )
    except Exception as e:
        logger.error(f"Failed to switch connection: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to switch connection: {str(e)}")


@router.delete("/{name}", response_model=ConnectionStatus)
async def delete_connection(name: str):
    """
    Delete a saved connection configuration.

    Cannot delete 'default' or the currently active connection.
    """
    global _saved_connections, _active_connection

    if name == "default":
        raise HTTPException(status_code=400, detail="Cannot delete default connection")

    if name == _active_connection:
        raise HTTPException(status_code=400, detail="Cannot delete active connection. Switch to another first.")

    if name not in _saved_connections:
        raise HTTPException(status_code=404, detail=f"Connection '{name}' not found")

    del _saved_connections[name]
    logger.info(f"Deleted connection: {name}")

    return ConnectionStatus(
        name=name,
        status="deleted",
        message=f"Connection '{name}' deleted successfully"
    )


@router.get("/active")
async def get_active_connection():
    """
    Get the currently active database connection info.
    """
    global _active_connection

    if _active_connection is None:
        return {
            "name": "default",
            "type": "postgresql",
            "host": "localhost",
            "database": "northwind",
            "is_default": True
        }

    config = _saved_connections.get(_active_connection)
    if config:
        return {
            "name": config.name,
            "type": config.db_type,
            "host": config.host,
            "database": config.database,
            "is_default": False
        }

    return {"name": "unknown", "is_default": False}
