"""
Rate Limiting Middleware for FastAPI
Generated by RTX 5090 (Qwen2.5-Coder-32B-AWQ)
"""
import time
from collections import defaultdict
from typing import Dict, Tuple
from fastapi import FastAPI, Request, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware
import os


class RateLimitExceeded(HTTPException):
    """Exception raised when rate limit is exceeded."""
    def __init__(self, retry_after: int):
        super().__init__(
            status_code=429,
            detail="Too Many Requests",
            headers={"Retry-After": str(retry_after)}
        )


class RateLimiter:
    """In-memory rate limiter with TTL cleanup."""

    def __init__(self, limit: int = 100, period: int = 60):
        self.limit = limit
        self.period = period
        self.requests: Dict[str, Tuple[int, int]] = defaultdict(lambda: (0, 0))

    def is_allowed(self, ip: str) -> bool:
        """Check if request from IP is allowed."""
        current_time = int(time.time())
        count, last_reset = self.requests[ip]
        if current_time - last_reset > self.period:
            self.requests[ip] = (1, current_time)
            return True
        elif count < self.limit:
            self.requests[ip] = (count + 1, last_reset)
            return True
        else:
            return False

    def cleanup(self) -> None:
        """Remove expired entries from the rate limiter."""
        current_time = int(time.time())
        for ip in list(self.requests.keys()):
            count, last_reset = self.requests[ip]
            if current_time - last_reset > self.period:
                del self.requests[ip]


class RateLimitingMiddleware(BaseHTTPMiddleware):
    """FastAPI middleware for rate limiting requests."""

    def __init__(self, app: FastAPI, limit: int = None, period: int = None):
        super().__init__(app)
        self.rate_limiter = RateLimiter(
            limit=limit or REQUEST_LIMIT,
            period=period or REQUEST_PERIOD
        )

    async def dispatch(self, request: Request, call_next):
        x_forwarded_for = request.headers.get('X-Forwarded-For')
        client_host = x_forwarded_for.split(',')[0] if x_forwarded_for else request.client.host

        if not self.rate_limiter.is_allowed(client_host):
            raise RateLimitExceeded(retry_after=self.rate_limiter.period)

        response = await call_next(request)
        return response


# Configuration from environment variables
REQUEST_LIMIT = int(os.getenv("REQUEST_LIMIT", 100))
REQUEST_PERIOD = int(os.getenv("REQUEST_PERIOD", 60))
