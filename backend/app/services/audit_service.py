"""
Audit Logging Service
Generated by: RTX 3050 (SQL schema), Expert AI (implementation)
Demonstrates escalation pattern when smaller model has issues
"""
import json
import logging
from datetime import datetime
from typing import Any, Dict, List, Optional
from dataclasses import dataclass, asdict

logger = logging.getLogger(__name__)

# SQL to create the audit_logs table (from RTX 3050)
CREATE_AUDIT_TABLE_SQL = """
CREATE TABLE IF NOT EXISTS audit_logs (
    id SERIAL PRIMARY KEY,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_id VARCHAR(255),
    action VARCHAR(50) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id VARCHAR(255) NOT NULL,
    old_value TEXT,
    new_value TEXT,
    ip_address VARCHAR(50),
    details JSONB
);

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp);
CREATE INDEX IF NOT EXISTS idx_audit_logs_entity ON audit_logs(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
"""


@dataclass
class AuditLogEntry:
    """Audit log entry data class."""
    action: str
    entity_type: str
    entity_id: str
    user_id: Optional[str] = None
    old_value: Optional[str] = None
    new_value: Optional[str] = None
    ip_address: Optional[str] = None
    details: Optional[Dict[str, Any]] = None
    timestamp: Optional[datetime] = None
    id: Optional[int] = None


class AuditService:
    """
    Service for audit logging of data quality operations.

    Tracks all CRUD operations on rules, profiles, and other entities
    for compliance and debugging purposes.
    """

    # Action constants
    ACTION_CREATE = "CREATE"
    ACTION_UPDATE = "UPDATE"
    ACTION_DELETE = "DELETE"
    ACTION_EXECUTE = "EXECUTE"
    ACTION_TOGGLE = "TOGGLE"
    ACTION_LOGIN = "LOGIN"
    ACTION_LOGOUT = "LOGOUT"

    # Entity type constants
    ENTITY_RULE = "data_quality_rule"
    ENTITY_PROFILE = "data_profile"
    ENTITY_CONNECTION = "database_connection"
    ENTITY_USER = "user"

    def __init__(self, pool):
        """Initialize audit service with database pool."""
        self._pool = pool

    async def initialize_table(self) -> None:
        """Create audit_logs table if it doesn't exist."""
        async with self._pool.acquire() as conn:
            await conn.execute(CREATE_AUDIT_TABLE_SQL)
            logger.info("Audit logs table initialized")

    async def log_action(
        self,
        action: str,
        entity_type: str,
        entity_id: str,
        user_id: Optional[str] = None,
        old_value: Any = None,
        new_value: Any = None,
        ip_address: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None
    ) -> int:
        """
        Log an audit action.

        Args:
            action: The action performed (CREATE, UPDATE, DELETE, etc.)
            entity_type: Type of entity (data_quality_rule, data_profile, etc.)
            entity_id: Unique identifier of the entity
            user_id: Optional user who performed the action
            old_value: Previous value (for updates/deletes)
            new_value: New value (for creates/updates)
            ip_address: Client IP address
            details: Additional context as JSON

        Returns:
            The ID of the created audit log entry
        """
        # Serialize values to JSON strings if they're dicts/objects
        old_value_str = json.dumps(old_value) if isinstance(old_value, (dict, list)) else str(old_value) if old_value else None
        new_value_str = json.dumps(new_value) if isinstance(new_value, (dict, list)) else str(new_value) if new_value else None
        details_json = json.dumps(details) if details else None

        async with self._pool.acquire() as conn:
            result = await conn.fetchrow(
                """
                INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_value, new_value, ip_address, details)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING id
                """,
                user_id, action, entity_type, str(entity_id),
                old_value_str, new_value_str, ip_address, details_json
            )
            log_id = result['id']
            logger.info(f"Audit log created: {action} on {entity_type}/{entity_id} (id={log_id})")
            return log_id

    async def get_audit_logs(
        self,
        entity_type: Optional[str] = None,
        entity_id: Optional[str] = None,
        action: Optional[str] = None,
        user_id: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        limit: int = 100,
        offset: int = 0
    ) -> List[AuditLogEntry]:
        """
        Retrieve audit logs with optional filtering.

        Args:
            entity_type: Filter by entity type
            entity_id: Filter by entity ID
            action: Filter by action type
            user_id: Filter by user
            start_date: Filter logs after this date
            end_date: Filter logs before this date
            limit: Maximum number of results
            offset: Pagination offset

        Returns:
            List of audit log entries
        """
        conditions = []
        params = []
        param_count = 0

        if entity_type:
            param_count += 1
            conditions.append(f"entity_type = ${param_count}")
            params.append(entity_type)

        if entity_id:
            param_count += 1
            conditions.append(f"entity_id = ${param_count}")
            params.append(str(entity_id))

        if action:
            param_count += 1
            conditions.append(f"action = ${param_count}")
            params.append(action)

        if user_id:
            param_count += 1
            conditions.append(f"user_id = ${param_count}")
            params.append(user_id)

        if start_date:
            param_count += 1
            conditions.append(f"timestamp >= ${param_count}")
            params.append(start_date)

        if end_date:
            param_count += 1
            conditions.append(f"timestamp <= ${param_count}")
            params.append(end_date)

        where_clause = " AND ".join(conditions) if conditions else "1=1"

        param_count += 1
        limit_param = param_count
        param_count += 1
        offset_param = param_count
        params.extend([limit, offset])

        query = f"""
            SELECT id, timestamp, user_id, action, entity_type, entity_id,
                   old_value, new_value, ip_address, details
            FROM audit_logs
            WHERE {where_clause}
            ORDER BY timestamp DESC
            LIMIT ${limit_param} OFFSET ${offset_param}
        """

        async with self._pool.acquire() as conn:
            rows = await conn.fetch(query, *params)

        return [
            AuditLogEntry(
                id=row['id'],
                timestamp=row['timestamp'],
                user_id=row['user_id'],
                action=row['action'],
                entity_type=row['entity_type'],
                entity_id=row['entity_id'],
                old_value=row['old_value'],
                new_value=row['new_value'],
                ip_address=row['ip_address'],
                details=json.loads(row['details']) if row['details'] else None
            )
            for row in rows
        ]

    async def get_entity_history(
        self,
        entity_type: str,
        entity_id: str,
        limit: int = 50
    ) -> List[AuditLogEntry]:
        """Get complete audit history for a specific entity."""
        return await self.get_audit_logs(
            entity_type=entity_type,
            entity_id=entity_id,
            limit=limit
        )

    async def get_recent_actions(
        self,
        action: str,
        limit: int = 20
    ) -> List[AuditLogEntry]:
        """Get recent actions of a specific type."""
        return await self.get_audit_logs(action=action, limit=limit)


# Singleton instance
_audit_service: Optional[AuditService] = None


async def get_audit_service(pool=None) -> AuditService:
    """Get or create the audit service singleton."""
    global _audit_service
    if _audit_service is None:
        if pool is None:
            from app.services.data_profiling_service import get_profiling_service
            profiling_service = await get_profiling_service()
            pool = profiling_service._pool
        _audit_service = AuditService(pool)
    return _audit_service
