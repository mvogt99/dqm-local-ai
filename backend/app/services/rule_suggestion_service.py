"""
Rule Suggestion Service - Analyzes profiles to suggest data quality rules
Generated by RTX 5090 (Qwen2.5-Coder-32B-AWQ)
"""
import re
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict
from enum import Enum


class RuleType(str, Enum):
    NULL_CHECK = "NULL_CHECK"
    UNIQUE_CHECK = "UNIQUE_CHECK"
    RANGE_CHECK = "RANGE_CHECK"
    PATTERN_CHECK = "PATTERN_CHECK"
    FOREIGN_KEY_CHECK = "FOREIGN_KEY_CHECK"


class Severity(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class SuggestedRule:
    """A suggested data quality rule."""
    rule_type: RuleType
    table: str
    column: str
    condition: str
    severity: Severity
    confidence_score: float
    description: str

    def to_dict(self) -> Dict[str, Any]:
        return {
            "rule_type": self.rule_type.value,
            "table": self.table,
            "column": self.column,
            "condition": self.condition,
            "severity": self.severity.value,
            "confidence_score": self.confidence_score,
            "description": self.description
        }


# Common patterns for pattern detection
PATTERNS = {
    "email": r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$",
    "phone": r"^[\d\s\-\(\)\+]+$",
    "date_iso": r"^\d{4}-\d{2}-\d{2}$",
    "url": r"^https?://",
    "postal_code": r"^\d{5}(-\d{4})?$",
}


def detect_pattern(sample_values: List[Any]) -> Optional[str]:
    """Detect common patterns in sample values."""
    if not sample_values:
        return None

    str_values = [str(v) for v in sample_values if v is not None]
    if not str_values:
        return None

    for pattern_name, regex in PATTERNS.items():
        matches = sum(1 for v in str_values if re.match(regex, v))
        if matches / len(str_values) >= 0.8:  # 80% match threshold
            return pattern_name

    return None


def suggest_rules_from_profile(table_profile: Dict[str, Any]) -> List[SuggestedRule]:
    """
    Analyze a table profile and suggest data quality rules.

    Args:
        table_profile: Dictionary containing table profile data

    Returns:
        List of suggested rules
    """
    suggested_rules = []
    table_name = table_profile.get("table_name", "unknown")
    row_count = table_profile.get("row_count", 0)
    columns = table_profile.get("columns", [])

    for column in columns:
        column_name = column.get("column_name", "unknown")
        null_count = column.get("null_count", 0)
        null_percent = column.get("null_percent", 0)
        unique_count = column.get("unique_count", 0)
        min_value = column.get("min_value")
        max_value = column.get("max_value")
        data_type = column.get("data_type", "")
        sample_values = column.get("sample_values", [])
        is_nullable = column.get("is_nullable", True)

        # NULL_CHECK: If column has nulls but shouldn't
        if null_count > 0:
            if null_percent > 50:
                severity = Severity.HIGH
            elif null_percent > 10:
                severity = Severity.MEDIUM
            else:
                severity = Severity.LOW

            suggested_rules.append(SuggestedRule(
                rule_type=RuleType.NULL_CHECK,
                table=table_name,
                column=column_name,
                condition=f"{column_name} IS NOT NULL",
                severity=severity,
                confidence_score=1.0 - (null_percent / 100),
                description=f"Column '{column_name}' has {null_percent:.1f}% null values ({null_count} rows)"
            ))

        # UNIQUE_CHECK: If column appears to be unique (ID, key)
        if row_count > 0 and unique_count == row_count:
            suggested_rules.append(SuggestedRule(
                rule_type=RuleType.UNIQUE_CHECK,
                table=table_name,
                column=column_name,
                condition=f"COUNT(DISTINCT {column_name}) = COUNT(*)",
                severity=Severity.MEDIUM,
                confidence_score=1.0,
                description=f"Column '{column_name}' has all unique values - likely a key column"
            ))

        # RANGE_CHECK: For numeric columns with min/max
        if min_value is not None and max_value is not None:
            if isinstance(min_value, (int, float)) and isinstance(max_value, (int, float)):
                suggested_rules.append(SuggestedRule(
                    rule_type=RuleType.RANGE_CHECK,
                    table=table_name,
                    column=column_name,
                    condition=f"{column_name} BETWEEN {min_value} AND {max_value}",
                    severity=Severity.LOW,
                    confidence_score=0.8,
                    description=f"Column '{column_name}' values range from {min_value} to {max_value}"
                ))

        # PATTERN_CHECK: For string columns
        if data_type in ('character varying', 'text', 'varchar', 'char'):
            pattern = detect_pattern(sample_values)
            if pattern:
                suggested_rules.append(SuggestedRule(
                    rule_type=RuleType.PATTERN_CHECK,
                    table=table_name,
                    column=column_name,
                    condition=f"{column_name} ~ '{PATTERNS[pattern]}'",
                    severity=Severity.MEDIUM,
                    confidence_score=0.85,
                    description=f"Column '{column_name}' appears to follow {pattern} pattern"
                ))

        # FOREIGN_KEY_CHECK: Detect potential FK columns
        if column_name.endswith('_id') or column_name.endswith('Id'):
            # Likely a foreign key
            suggested_rules.append(SuggestedRule(
                rule_type=RuleType.FOREIGN_KEY_CHECK,
                table=table_name,
                column=column_name,
                condition=f"{column_name} IN (SELECT id FROM referenced_table)",
                severity=Severity.HIGH,
                confidence_score=0.7,
                description=f"Column '{column_name}' appears to be a foreign key reference"
            ))

    return suggested_rules
