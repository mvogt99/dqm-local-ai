"""
Data Lineage Service
Generated by: RTX 5090 (architecture), RTX 3050 (implementation), Expert AI (enhancement)
Tracks data flow and column-level lineage between tables
"""
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

CREATE_LINEAGE_TABLES = """
CREATE TABLE IF NOT EXISTS data_lineage (
    id SERIAL PRIMARY KEY,
    source_table VARCHAR(255) NOT NULL,
    source_column VARCHAR(255),
    target_table VARCHAR(255) NOT NULL,
    target_column VARCHAR(255),
    transformation_type VARCHAR(100),
    transformation_details TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_lineage_source ON data_lineage(source_table);
CREATE INDEX IF NOT EXISTS idx_lineage_target ON data_lineage(target_table);
"""


class DataLineageService:
    """
    Data lineage tracking service.
    
    Generated by RTX 3050, enhanced by Expert AI.
    Tracks data flow between tables and columns.
    """

    def __init__(self, pool):
        self._pool = pool

    async def initialize_tables(self) -> None:
        """Create lineage tables if they don't exist."""
        async with self._pool.acquire() as conn:
            await conn.execute(CREATE_LINEAGE_TABLES)
            logger.info("Lineage tables initialized")

    async def track_lineage(
        self,
        source_table: str,
        source_column: Optional[str],
        target_table: str,
        target_column: Optional[str],
        transformation_type: str = "direct",
        transformation_details: Optional[str] = None
    ) -> int:
        """Track lineage between source and target."""
        async with self._pool.acquire() as conn:
            result = await conn.fetchrow("""
                INSERT INTO data_lineage 
                (source_table, source_column, target_table, target_column, 
                 transformation_type, transformation_details)
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING id
            """, source_table, source_column, target_table, target_column,
                transformation_type, transformation_details)
            return result['id']

    async def get_table_lineage(self, table_name: str) -> List[Dict[str, Any]]:
        """Get all lineage records involving a table."""
        async with self._pool.acquire() as conn:
            rows = await conn.fetch("""
                SELECT * FROM data_lineage 
                WHERE source_table = $1 OR target_table = $1
                ORDER BY created_at DESC
            """, table_name)
            return [dict(row) for row in rows]

    async def get_upstream(self, table_name: str) -> List[Dict[str, Any]]:
        """Get upstream tables (sources) for a table."""
        async with self._pool.acquire() as conn:
            rows = await conn.fetch("""
                SELECT DISTINCT source_table, source_column, transformation_type
                FROM data_lineage WHERE target_table = $1
            """, table_name)
            return [dict(row) for row in rows]

    async def get_downstream(self, table_name: str) -> List[Dict[str, Any]]:
        """Get downstream tables (targets) for a table."""
        async with self._pool.acquire() as conn:
            rows = await conn.fetch("""
                SELECT DISTINCT target_table, target_column, transformation_type
                FROM data_lineage WHERE source_table = $1
            """, table_name)
            return [dict(row) for row in rows]

    async def get_impact_analysis(self, table_name: str) -> Dict[str, Any]:
        """Analyze impact of changes to a table."""
        downstream = await self.get_downstream(table_name)
        affected_tables = set(d['target_table'] for d in downstream)
        
        return {
            "source_table": table_name,
            "affected_tables": list(affected_tables),
            "affected_count": len(affected_tables),
            "lineage_details": downstream
        }


_lineage_service: Optional[DataLineageService] = None

async def get_lineage_service(pool=None) -> DataLineageService:
    global _lineage_service
    if _lineage_service is None:
        if pool is None:
            from app.services.data_profiling_service import get_profiling_service
            ps = await get_profiling_service()
            pool = ps._pool
        _lineage_service = DataLineageService(pool)
    return _lineage_service
