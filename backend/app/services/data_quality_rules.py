"""
Data Quality Rules Service - Fixed asyncpg usage
Generated by RTX 5090 (Qwen2.5-Coder-32B-Instruct-AWQ)
"""
import asyncpg
from typing import List, Dict, Any


class DataQualityRulesService:
    """Service for managing data quality rules."""

    def __init__(self, dsn: str):
        self.dsn = dsn

    async def suggest_rules(self, profiling_results: List[Dict]) -> List[Dict]:
        """
        Suggest data quality rules based on profiling results.

        Rule Types:
        - null_check: For columns with null values
        - unique_check: For columns that appear to be unique identifiers
        - range_check: For numeric columns with potential outliers
        - pattern_check: For string columns with consistent patterns
        - not_null: For critical columns that should never be null

        Enhanced by RTX 5090 to provide diverse, column-specific rules.
        """
        suggested_rules = []

        for result in profiling_results:
            table = result.get('table', 'unknown')
            column = result.get('column', 'unknown')
            null_pct = result.get('null_percentage', 0) or 0
            unique_count = result.get('unique_count', 0) or 0
            data_type = result.get('data_type', '').lower()

            # Rule 1: NULL Check - For columns with nulls
            if null_pct > 0.01:  # More than 1% nulls
                severity = 'critical' if null_pct > 0.1 else 'warning' if null_pct > 0.05 else 'info'
                suggested_rules.append({
                    'name': f"null_check_{table}_{column}",
                    'table': table,
                    'column': column,
                    'rule_type': 'null_check',
                    'definition': f"SELECT * FROM {table} WHERE {column} IS NULL",
                    'severity': severity,
                    'reason': f"Column has {null_pct*100:.1f}% null values",
                    'threshold': 0 if null_pct < 0.05 else 5
                })

            # Rule 2: NOT NULL Check - For columns that SHOULD be null-free
            if null_pct == 0 and column.lower() in ['id', 'name', 'email', 'customer_id', 'order_id', 'product_id']:
                suggested_rules.append({
                    'name': f"not_null_{table}_{column}",
                    'table': table,
                    'column': column,
                    'rule_type': 'not_null',
                    'definition': f"SELECT * FROM {table} WHERE {column} IS NULL",
                    'severity': 'critical',
                    'reason': f"Critical column should never be null"
                })

            # Rule 3: Unique Check - For columns that appear to be unique
            if unique_count > 0 and column.lower().endswith(('_id', 'id', 'email', 'phone', 'code')):
                suggested_rules.append({
                    'name': f"unique_check_{table}_{column}",
                    'table': table,
                    'column': column,
                    'rule_type': 'unique_check',
                    'definition': f"SELECT {column}, COUNT(*) FROM {table} GROUP BY {column} HAVING COUNT(*) > 1",
                    'severity': 'warning',
                    'reason': f"Column appears to be a unique identifier"
                })

            # Rule 4: Range Check - For numeric columns
            if data_type in ['integer', 'numeric', 'decimal', 'float', 'double', 'int', 'bigint', 'smallint']:
                if column.lower() in ['price', 'unit_price', 'amount', 'total', 'cost', 'quantity', 'units_in_stock']:
                    suggested_rules.append({
                        'name': f"range_check_{table}_{column}",
                        'table': table,
                        'column': column,
                        'rule_type': 'range_check',
                        'definition': f"SELECT * FROM {table} WHERE {column} < 0",
                        'severity': 'critical',
                        'reason': f"Numeric column should have non-negative values",
                        'min_value': 0
                    })

            # Rule 5: Pattern Check - For string columns with expected formats
            if data_type in ['varchar', 'text', 'character varying', 'char']:
                if 'email' in column.lower():
                    suggested_rules.append({
                        'name': f"pattern_check_{table}_{column}",
                        'table': table,
                        'column': column,
                        'rule_type': 'pattern_check',
                        'definition': f"SELECT * FROM {table} WHERE {column} !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{{2,}}$'",
                        'severity': 'warning',
                        'reason': f"Email column should match email format",
                        'pattern': '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$'
                    })
                elif 'phone' in column.lower():
                    suggested_rules.append({
                        'name': f"pattern_check_{table}_{column}",
                        'table': table,
                        'column': column,
                        'rule_type': 'pattern_check',
                        'definition': f"SELECT * FROM {table} WHERE {column} !~ '^[0-9()\\-+ ]+$'",
                        'severity': 'info',
                        'reason': f"Phone column should contain valid phone characters",
                        'pattern': '^[0-9()\\-+ ]+$'
                    })
                elif 'postal' in column.lower() or 'zip' in column.lower():
                    suggested_rules.append({
                        'name': f"pattern_check_{table}_{column}",
                        'table': table,
                        'column': column,
                        'rule_type': 'pattern_check',
                        'definition': f"SELECT * FROM {table} WHERE {column} !~ '^[A-Za-z0-9 -]+$'",
                        'severity': 'info',
                        'reason': f"Postal code should match expected format",
                        'pattern': '^[A-Za-z0-9 -]+$'
                    })

        return suggested_rules

    async def create_rule(self, name: str, table: str, column: str, rule_type: str, definition: str, severity: str):
        """Create a new data quality rule."""
        conn = await asyncpg.connect(self.dsn)
        try:
            await conn.execute('''
                INSERT INTO data_quality_rules (name, table_name, column_name, rule_type, definition, severity)
                VALUES ($1, $2, $3, $4, $5, $6)
            ''', name, table, column, rule_type, definition, severity)
        finally:
            await conn.close()

    async def execute_rule(self, rule_id: int) -> Dict[str, Any]:
        """Execute a data quality rule and store results."""
        conn = await asyncpg.connect(self.dsn)
        try:
            rule = await conn.fetchrow('SELECT * FROM data_quality_rules WHERE id = $1', rule_id)
            if not rule:
                return {"error": "Rule not found"}
            query = rule['definition']
            failures = await conn.fetch(query)
            await conn.execute('''
                INSERT INTO data_quality_results (rule_id, failures)
                VALUES ($1, $2)
            ''', rule_id, str(failures))
            return {"rule_id": rule_id, "executed": True, "failure_count": len(failures)}
        finally:
            await conn.close()

    async def get_all_rules(self) -> List[Dict]:
        """Get all active data quality rules."""
        conn = await asyncpg.connect(self.dsn)
        try:
            # First check if table exists
            table_exists = await conn.fetchval('''
                SELECT EXISTS (
                    SELECT FROM information_schema.tables
                    WHERE table_name = 'data_quality_rules'
                )
            ''')
            if not table_exists:
                return []
            rules = await conn.fetch('SELECT * FROM data_quality_rules')
            return [dict(rule) for rule in rules]
        except Exception:
            return []
        finally:
            await conn.close()

    async def get_failures(self, rule_id: int) -> List[str]:
        """Get failures for a specific rule."""
        conn = await asyncpg.connect(self.dsn)
        try:
            table_exists = await conn.fetchval('''
                SELECT EXISTS (
                    SELECT FROM information_schema.tables
                    WHERE table_name = 'data_quality_results'
                )
            ''')
            if not table_exists:
                return []
            failures = await conn.fetch('SELECT failures FROM data_quality_results WHERE rule_id = $1', rule_id)
            return [str(failure['failures']) for failure in failures]
        except Exception:
            return []
        finally:
            await conn.close()
