"""
Real Data Profiling Service - Connects to PostgreSQL
Generated by RTX 5090 (Qwen2.5-Coder-32B-AWQ)
"""
import os
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict
import asyncpg
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://dqm_user:dqm_pass@localhost:5432/northwind")
TABLE_WHITELIST = {"customers", "orders", "products", "employees", "order_details",
                   "categories", "shippers", "suppliers", "territories", "region"}


@dataclass
class ColumnProfile:
    """Profile of a single column."""
    column_name: str
    data_type: str
    is_nullable: bool
    null_count: int
    null_percent: float
    unique_count: int
    min_value: Optional[Any]
    max_value: Optional[Any]
    sample_values: List[Any]


@dataclass
class TableProfile:
    """Complete profile of a table."""
    table_name: str
    row_count: int
    column_count: int
    columns: List[ColumnProfile]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "table_name": self.table_name,
            "row_count": self.row_count,
            "column_count": self.column_count,
            "columns": [asdict(col) for col in self.columns]
        }


class DataProfilingService:
    """Service for profiling database tables with REAL queries."""

    def __init__(self, database_url: str = None):
        self.database_url = database_url or DATABASE_URL
        self.pool: Optional[asyncpg.Pool] = None

    async def connect(self) -> None:
        """Create connection pool."""
        self.pool = await asyncpg.create_pool(self.database_url, min_size=2, max_size=10)
        logger.info("Database connection pool created")

    async def disconnect(self) -> None:
        """Close connection pool."""
        if self.pool:
            await self.pool.close()
            logger.info("Database connection pool closed")

    async def get_tables(self) -> List[str]:
        """Get list of available tables (filtered by whitelist)."""
        query = """
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'public' AND table_type = 'BASE TABLE'
        """
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query)
            tables = [row['table_name'] for row in rows]
            return [t for t in tables if t in TABLE_WHITELIST]

    async def profile_table(self, table_name: str) -> TableProfile:
        """Profile a table with REAL database queries."""
        if table_name not in TABLE_WHITELIST:
            raise ValueError(f"Table '{table_name}' is not in the whitelist")

        async with self.pool.acquire() as conn:
            # Get row count
            row_count = await self._get_row_count(conn, table_name)

            # Get column info
            columns_info = await self._get_columns_info(conn, table_name)

            # Profile each column
            column_profiles = []
            for col_info in columns_info:
                profile = await self._profile_column(
                    conn, table_name, col_info, row_count
                )
                column_profiles.append(profile)

            return TableProfile(
                table_name=table_name,
                row_count=row_count,
                column_count=len(column_profiles),
                columns=column_profiles
            )

    async def _get_row_count(self, conn: asyncpg.Connection, table_name: str) -> int:
        """Get row count for a table."""
        # Using identifier quoting for safety
        row = await conn.fetchrow(f'SELECT COUNT(*) as cnt FROM "{table_name}"')
        return row['cnt'] if row else 0

    async def _get_columns_info(self, conn: asyncpg.Connection, table_name: str) -> List[Dict]:
        """Get column information from information_schema."""
        query = """
        SELECT column_name, data_type, is_nullable
        FROM information_schema.columns
        WHERE table_name = $1 AND table_schema = 'public'
        ORDER BY ordinal_position
        """
        rows = await conn.fetch(query, table_name)
        return [dict(row) for row in rows]

    async def _profile_column(
        self,
        conn: asyncpg.Connection,
        table_name: str,
        col_info: Dict,
        row_count: int
    ) -> ColumnProfile:
        """Profile a single column."""
        column_name = col_info['column_name']
        data_type = col_info['data_type']
        is_nullable = col_info['is_nullable'] == 'YES'

        # Null count
        null_row = await conn.fetchrow(
            f'SELECT COUNT(*) as cnt FROM "{table_name}" WHERE "{column_name}" IS NULL'
        )
        null_count = null_row['cnt'] if null_row else 0
        null_percent = (null_count / row_count * 100) if row_count > 0 else 0

        # Unique count
        unique_row = await conn.fetchrow(
            f'SELECT COUNT(DISTINCT "{column_name}") as cnt FROM "{table_name}"'
        )
        unique_count = unique_row['cnt'] if unique_row else 0

        # Min/Max for numeric types
        min_value = None
        max_value = None
        if data_type in ('integer', 'smallint', 'bigint', 'decimal', 'numeric',
                         'real', 'double precision', 'money'):
            try:
                minmax_row = await conn.fetchrow(
                    f'SELECT MIN("{column_name}") as min_val, MAX("{column_name}") as max_val FROM "{table_name}"'
                )
                if minmax_row:
                    min_value = minmax_row['min_val']
                    max_value = minmax_row['max_val']
            except Exception as e:
                logger.warning(f"Could not get min/max for {column_name}: {e}")

        # Sample values
        sample_rows = await conn.fetch(
            f'SELECT "{column_name}" FROM "{table_name}" WHERE "{column_name}" IS NOT NULL LIMIT 5'
        )
        sample_values = [row[column_name] for row in sample_rows]

        return ColumnProfile(
            column_name=column_name,
            data_type=data_type,
            is_nullable=is_nullable,
            null_count=null_count,
            null_percent=round(null_percent, 2),
            unique_count=unique_count,
            min_value=min_value,
            max_value=max_value,
            sample_values=sample_values
        )


# Singleton instance
_profiling_service: Optional[DataProfilingService] = None


async def get_profiling_service() -> DataProfilingService:
    """Get or create profiling service singleton."""
    global _profiling_service
    if _profiling_service is None:
        _profiling_service = DataProfilingService()
        await _profiling_service.connect()
    return _profiling_service
