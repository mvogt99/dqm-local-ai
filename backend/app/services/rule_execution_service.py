"""
Rule Execution Service - Executes data quality rules against PostgreSQL
Generated by RTX 3050 (Qwen2.5-Coder-7B-Instruct)
"""
import asyncio
import asyncpg
import time
import logging
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
from enum import Enum

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class RuleType(str, Enum):
    NULL_CHECK = "NULL_CHECK"
    UNIQUE_CHECK = "UNIQUE_CHECK"
    RANGE_CHECK = "RANGE_CHECK"
    PATTERN_CHECK = "PATTERN_CHECK"


@dataclass
class RuleResult:
    """Result of executing a data quality rule."""
    rule_id: str
    rule_type: str
    table: str
    column: str
    passed: bool
    violation_count: int
    sample_violations: Optional[List[Any]]
    execution_time_ms: float

    def to_dict(self) -> Dict[str, Any]:
        return {
            "rule_id": self.rule_id,
            "rule_type": self.rule_type,
            "table": self.table,
            "column": self.column,
            "passed": self.passed,
            "violation_count": self.violation_count,
            "sample_violations": self.sample_violations,
            "execution_time_ms": round(self.execution_time_ms, 2)
        }


TABLE_WHITELIST = {"customers", "orders", "products", "employees", "order_details",
                   "categories", "shippers", "suppliers", "territories", "region"}


class RuleExecutionService:
    """Service for executing data quality rules with REAL queries."""

    def __init__(self, database_url: str):
        self.database_url = database_url
        self.pool: Optional[asyncpg.Pool] = None

    async def connect(self) -> None:
        """Create connection pool."""
        self.pool = await asyncpg.create_pool(self.database_url, min_size=2, max_size=10)
        logger.info("Rule execution service connected to database")

    async def disconnect(self) -> None:
        """Close connection pool."""
        if self.pool:
            await self.pool.close()

    async def execute_rule(
        self,
        rule_id: str,
        rule_type: str,
        table_name: str,
        column_name: str,
        params: Optional[Dict[str, Any]] = None
    ) -> RuleResult:
        """Execute a single data quality rule."""
        if table_name not in TABLE_WHITELIST:
            raise ValueError(f"Table '{table_name}' is not in the whitelist")

        params = params or {}
        start_time = time.time()

        async with self.pool.acquire() as conn:
            try:
                violation_count = await self._count_violations(
                    conn, rule_type, table_name, column_name, params
                )
                passed = violation_count == 0

                sample_violations = None
                if not passed:
                    sample_violations = await self._get_sample_violations(
                        conn, rule_type, table_name, column_name, params
                    )

                execution_time_ms = (time.time() - start_time) * 1000

                logger.info(
                    f"Rule {rule_id} executed: passed={passed}, violations={violation_count}"
                )

                return RuleResult(
                    rule_id=rule_id,
                    rule_type=rule_type,
                    table=table_name,
                    column=column_name,
                    passed=passed,
                    violation_count=violation_count,
                    sample_violations=sample_violations,
                    execution_time_ms=execution_time_ms
                )

            except Exception as e:
                logger.error(f"Error executing rule {rule_id}: {e}")
                raise

    async def _count_violations(
        self,
        conn: asyncpg.Connection,
        rule_type: str,
        table_name: str,
        column_name: str,
        params: Dict[str, Any]
    ) -> int:
        """Count violations for a rule type."""
        query = self._build_count_query(rule_type, table_name, column_name, params)
        row = await conn.fetchrow(query)
        return row['cnt'] if row else 0

    def _build_count_query(
        self,
        rule_type: str,
        table_name: str,
        column_name: str,
        params: Dict[str, Any]
    ) -> str:
        """Build SQL query to count violations."""
        if rule_type == RuleType.NULL_CHECK:
            return f'SELECT COUNT(*) as cnt FROM "{table_name}" WHERE "{column_name}" IS NULL'

        elif rule_type == RuleType.UNIQUE_CHECK:
            return f'''
                SELECT COUNT(*) as cnt FROM (
                    SELECT "{column_name}"
                    FROM "{table_name}"
                    GROUP BY "{column_name}"
                    HAVING COUNT(*) > 1
                ) duplicates
            '''

        elif rule_type == RuleType.RANGE_CHECK:
            min_val = params.get('min', 0)
            max_val = params.get('max', 999999999)
            return f'''
                SELECT COUNT(*) as cnt
                FROM "{table_name}"
                WHERE "{column_name}" < {min_val} OR "{column_name}" > {max_val}
            '''

        elif rule_type == RuleType.PATTERN_CHECK:
            pattern = params.get('pattern', '.*')
            return f'''
                SELECT COUNT(*) as cnt
                FROM "{table_name}"
                WHERE "{column_name}"::text !~ '{pattern}'
            '''

        else:
            raise ValueError(f"Unsupported rule type: {rule_type}")

    async def _get_sample_violations(
        self,
        conn: asyncpg.Connection,
        rule_type: str,
        table_name: str,
        column_name: str,
        params: Dict[str, Any],
        limit: int = 10
    ) -> List[Any]:
        """Get sample violations for a rule."""
        query = self._build_sample_query(rule_type, table_name, column_name, params, limit)
        rows = await conn.fetch(query)
        return [row[column_name] for row in rows]

    def _build_sample_query(
        self,
        rule_type: str,
        table_name: str,
        column_name: str,
        params: Dict[str, Any],
        limit: int
    ) -> str:
        """Build SQL query to get sample violations."""
        if rule_type == RuleType.NULL_CHECK:
            return f'''
                SELECT "{column_name}"
                FROM "{table_name}"
                WHERE "{column_name}" IS NULL
                LIMIT {limit}
            '''

        elif rule_type == RuleType.UNIQUE_CHECK:
            return f'''
                SELECT "{column_name}"
                FROM "{table_name}"
                WHERE "{column_name}" IN (
                    SELECT "{column_name}"
                    FROM "{table_name}"
                    GROUP BY "{column_name}"
                    HAVING COUNT(*) > 1
                )
                LIMIT {limit}
            '''

        elif rule_type == RuleType.RANGE_CHECK:
            min_val = params.get('min', 0)
            max_val = params.get('max', 999999999)
            return f'''
                SELECT "{column_name}"
                FROM "{table_name}"
                WHERE "{column_name}" < {min_val} OR "{column_name}" > {max_val}
                LIMIT {limit}
            '''

        elif rule_type == RuleType.PATTERN_CHECK:
            pattern = params.get('pattern', '.*')
            return f'''
                SELECT "{column_name}"
                FROM "{table_name}"
                WHERE "{column_name}"::text !~ '{pattern}'
                LIMIT {limit}
            '''

        else:
            raise ValueError(f"Unsupported rule type: {rule_type}")
