"""
Azure Active Directory Authentication Service
Generated by RTX 3050 (Qwen2.5-Coder-7B-Instruct), enhanced by Expert

Features:
- OAuth 2.0 / OpenID Connect integration
- JWT token validation
- Protected route dependency injection
- Session management
"""
import os
from typing import Optional, Dict, Any
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2AuthorizationCodeBearer
from pydantic import BaseModel
from pydantic_settings import BaseSettings
from functools import lru_cache
import httpx
import jwt
from jwt import PyJWKClient


class AzureADSettings(BaseSettings):
    """Azure AD configuration via environment variables."""

    AZURE_CLIENT_ID: str = ""
    AZURE_CLIENT_SECRET: str = ""
    AZURE_TENANT_ID: str = ""
    AZURE_REDIRECT_URI: str = "http://localhost:8001/auth/callback"
    AZURE_SCOPES: str = "openid profile email"

    # Optional: Enable/disable Azure auth
    AZURE_AUTH_ENABLED: bool = False

    class Config:
        env_file = ".env"
        extra = "ignore"

    @property
    def authority(self) -> str:
        return f"https://login.microsoftonline.com/{self.AZURE_TENANT_ID}"

    @property
    def authorization_url(self) -> str:
        return f"{self.authority}/oauth2/v2.0/authorize"

    @property
    def token_url(self) -> str:
        return f"{self.authority}/oauth2/v2.0/token"

    @property
    def jwks_url(self) -> str:
        return f"{self.authority}/discovery/v2.0/keys"

    @property
    def scopes_list(self) -> list:
        return self.AZURE_SCOPES.split()


@lru_cache()
def get_azure_settings() -> AzureADSettings:
    """Get cached Azure AD settings."""
    return AzureADSettings()


class UserInfo(BaseModel):
    """User information from Azure AD token."""
    id: str
    email: Optional[str] = None
    name: Optional[str] = None
    preferred_username: Optional[str] = None
    roles: list = []


class TokenResponse(BaseModel):
    """OAuth token response."""
    access_token: str
    token_type: str = "Bearer"
    expires_in: int = 3600
    refresh_token: Optional[str] = None
    id_token: Optional[str] = None


class AzureAuthService:
    """Azure AD authentication service."""

    def __init__(self, settings: AzureADSettings = None):
        self.settings = settings or get_azure_settings()
        self._jwks_client = None

    @property
    def jwks_client(self) -> PyJWKClient:
        """Lazy-load JWKS client."""
        if self._jwks_client is None:
            self._jwks_client = PyJWKClient(self.settings.jwks_url)
        return self._jwks_client

    def get_authorization_url(self, state: str = None) -> str:
        """Generate Azure AD login URL."""
        params = {
            "client_id": self.settings.AZURE_CLIENT_ID,
            "response_type": "code",
            "redirect_uri": self.settings.AZURE_REDIRECT_URI,
            "scope": self.settings.AZURE_SCOPES,
            "response_mode": "query",
        }
        if state:
            params["state"] = state

        query = "&".join(f"{k}={v}" for k, v in params.items())
        return f"{self.settings.authorization_url}?{query}"

    async def exchange_code_for_tokens(self, code: str) -> TokenResponse:
        """Exchange authorization code for tokens."""
        async with httpx.AsyncClient() as client:
            response = await client.post(
                self.settings.token_url,
                data={
                    "client_id": self.settings.AZURE_CLIENT_ID,
                    "client_secret": self.settings.AZURE_CLIENT_SECRET,
                    "code": code,
                    "redirect_uri": self.settings.AZURE_REDIRECT_URI,
                    "grant_type": "authorization_code",
                    "scope": self.settings.AZURE_SCOPES,
                },
            )

            if response.status_code != 200:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Failed to exchange code: {response.text}"
                )

            data = response.json()
            return TokenResponse(**data)

    async def refresh_access_token(self, refresh_token: str) -> TokenResponse:
        """Refresh access token using refresh token."""
        async with httpx.AsyncClient() as client:
            response = await client.post(
                self.settings.token_url,
                data={
                    "client_id": self.settings.AZURE_CLIENT_ID,
                    "client_secret": self.settings.AZURE_CLIENT_SECRET,
                    "refresh_token": refresh_token,
                    "grant_type": "refresh_token",
                    "scope": self.settings.AZURE_SCOPES,
                },
            )

            if response.status_code != 200:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Failed to refresh token"
                )

            data = response.json()
            return TokenResponse(**data)

    def validate_token(self, token: str) -> Dict[str, Any]:
        """Validate and decode JWT token."""
        try:
            signing_key = self.jwks_client.get_signing_key_from_jwt(token)
            payload = jwt.decode(
                token,
                signing_key.key,
                algorithms=["RS256"],
                audience=self.settings.AZURE_CLIENT_ID,
                issuer=f"{self.settings.authority}/v2.0",
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has expired"
            )
        except jwt.InvalidTokenError as e:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Invalid token: {str(e)}"
            )

    def get_user_info(self, token_payload: Dict[str, Any]) -> UserInfo:
        """Extract user info from token payload."""
        return UserInfo(
            id=token_payload.get("oid", token_payload.get("sub", "")),
            email=token_payload.get("email"),
            name=token_payload.get("name"),
            preferred_username=token_payload.get("preferred_username"),
            roles=token_payload.get("roles", []),
        )


# OAuth2 scheme for FastAPI
oauth2_scheme = OAuth2AuthorizationCodeBearer(
    authorizationUrl=get_azure_settings().authorization_url,
    tokenUrl=get_azure_settings().token_url,
    auto_error=False,
)


async def get_current_user(
    token: Optional[str] = Depends(oauth2_scheme),
) -> Optional[UserInfo]:
    """Dependency to get current authenticated user."""
    settings = get_azure_settings()

    # If auth is disabled, return None (allow anonymous)
    if not settings.AZURE_AUTH_ENABLED:
        return None

    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )

    service = AzureAuthService(settings)
    payload = service.validate_token(token)
    return service.get_user_info(payload)


async def require_auth(
    user: Optional[UserInfo] = Depends(get_current_user),
) -> UserInfo:
    """Dependency that requires authentication."""
    settings = get_azure_settings()

    if not settings.AZURE_AUTH_ENABLED:
        # Return mock user when auth is disabled
        return UserInfo(id="anonymous", name="Anonymous User")

    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required",
        )

    return user
