"""
DQM API Routes - REAL Implementation with Database Connectivity
Generated by RTX 5090 (Qwen2.5-Coder-32B-AWQ)

This replaces the MOCK implementation with REAL database queries.
"""
from fastapi import APIRouter, HTTPException, Path, Body
from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional
import os

# Import REAL services
from app.services.data_profiling_service import get_profiling_service
from app.services.rule_suggestion_service import suggest_rules_from_profile, SuggestedRule
from app.services.rule_execution_service import RuleExecutionService, RuleResult
from app.services.ai_analysis_service import analyze_data_quality

# Router setup
router = APIRouter(prefix="/api")

# Database URL
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://dqm_user:dqm_pass@localhost:5432/northwind")

# Table whitelist
TABLE_WHITELIST = {"customers", "orders", "products", "employees", "suppliers",
                   "categories", "shippers", "order_details", "territories", "region"}

# In-memory rule storage (for demo - would use database in production)
_rules_store: Dict[int, Dict] = {}
_rule_counter = 0

# Analysis history
_analysis_history: List[Dict] = []


# Pydantic models
class Rule(BaseModel):
    id: int
    name: str
    description: str
    condition: str
    rule_type: Optional[str] = "CUSTOM"
    table: Optional[str] = None
    column: Optional[str] = None


class RuleCreateRequest(BaseModel):
    name: str = Field(..., example="Check Nulls")
    description: str = Field(..., example="Ensure no null values")
    condition: str = Field(..., example="column IS NOT NULL")
    rule_type: Optional[str] = "CUSTOM"
    table: Optional[str] = None
    column: Optional[str] = None


class RuleExecuteRequest(BaseModel):
    rule_type: str = Field(..., example="NULL_CHECK")
    table: str = Field(..., example="customers")
    column: str = Field(..., example="contact_name")
    params: Optional[Dict[str, Any]] = None


class AIAnalysisRequest(BaseModel):
    table: str = Field(..., example="orders")
    violations: List[Dict[str, Any]] = Field(default_factory=list)
    profile: Optional[Dict[str, Any]] = None


class AnalysisResult(BaseModel):
    id: int
    timestamp: str
    table: str
    root_causes: List[str]
    recommendations: List[str]
    confidence_score: float


# Dependency to validate table names
def validate_table_name(table: str = Path(...)):
    if table not in TABLE_WHITELIST:
        raise HTTPException(status_code=400, detail=f"Table '{table}' is not in the whitelist.")
    return table


# Profile Routes - REAL IMPLEMENTATION
@router.get("/profile/tables", response_model=List[str])
async def list_tables():
    """List all available tables from the database."""
    try:
        service = await get_profiling_service()
        tables = await service.get_tables()
        return tables
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to list tables: {str(e)}")


@router.get("/profile/{table}")
async def profile_table(table: str):
    """Profile a table with REAL database queries."""
    if table not in TABLE_WHITELIST:
        raise HTTPException(status_code=400, detail=f"Table '{table}' is not in the whitelist.")

    try:
        service = await get_profiling_service()
        profile = await service.profile_table(table)
        return profile.to_dict()
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to profile table: {str(e)}")


# Rules Routes - REAL IMPLEMENTATION
@router.get("/rules", response_model=List[Rule])
async def list_rules():
    """List all stored rules."""
    return [Rule(**r) for r in _rules_store.values()]


@router.post("/rules", response_model=Rule, status_code=201)
async def create_rule(rule: RuleCreateRequest):
    """Create a new data quality rule."""
    global _rule_counter
    _rule_counter += 1
    new_rule = {
        "id": _rule_counter,
        "name": rule.name,
        "description": rule.description,
        "condition": rule.condition,
        "rule_type": rule.rule_type,
        "table": rule.table,
        "column": rule.column
    }
    _rules_store[_rule_counter] = new_rule
    return Rule(**new_rule)


@router.delete("/rules/{id}", status_code=204)
async def delete_rule(id: int):
    """Delete a rule by ID."""
    if id in _rules_store:
        del _rules_store[id]
    else:
        raise HTTPException(status_code=404, detail=f"Rule {id} not found")


@router.post("/rules/suggest")
async def suggest_rules(table: str = Body(..., embed=True)):
    """Suggest data quality rules based on table profile."""
    if table not in TABLE_WHITELIST:
        raise HTTPException(status_code=400, detail=f"Table '{table}' is not in the whitelist.")

    try:
        # Get table profile first
        service = await get_profiling_service()
        profile = await service.profile_table(table)

        # Suggest rules based on profile
        suggested = suggest_rules_from_profile(profile.to_dict())
        return {"table": table, "suggested_rules": [r.to_dict() for r in suggested]}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to suggest rules: {str(e)}")


@router.post("/rules/execute")
async def execute_rule(request: RuleExecuteRequest):
    """Execute a data quality rule against the database."""
    if request.table not in TABLE_WHITELIST:
        raise HTTPException(status_code=400, detail=f"Table '{request.table}' is not in the whitelist.")

    try:
        service = RuleExecutionService(DATABASE_URL)
        await service.connect()

        result = await service.execute_rule(
            rule_id=f"manual_{request.rule_type}_{request.column}",
            rule_type=request.rule_type,
            table_name=request.table,
            column_name=request.column,
            params=request.params
        )

        await service.disconnect()
        return result.to_dict()
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to execute rule: {str(e)}")


# Analysis Routes - REAL IMPLEMENTATION using LOCAL AI
@router.post("/analysis/ai")
async def ai_root_cause_analysis(request: AIAnalysisRequest):
    """
    Perform AI-powered root cause analysis using LOCAL AI (RTX 5090).

    This calls the LOCAL AI service to analyze data quality issues
    and provide recommendations.
    """
    try:
        # Get profile if not provided
        profile_data = request.profile
        if not profile_data:
            service = await get_profiling_service()
            profile = await service.profile_table(request.table)
            profile_data = profile.to_dict()

        # Call LOCAL AI for analysis
        result = await analyze_data_quality(
            violations=request.violations,
            profile_data=profile_data,
            table_name=request.table
        )

        # Store in history
        from datetime import datetime
        analysis_record = {
            "id": len(_analysis_history) + 1,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "table": request.table,
            "root_causes": result.root_causes,
            "recommendations": result.recommendations,
            "confidence_score": result.confidence_score,
            "additional_rules": result.additional_rules
        }
        _analysis_history.append(analysis_record)

        return result.to_dict()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"AI analysis failed: {str(e)}")


@router.get("/analysis/history", response_model=List[AnalysisResult])
async def get_analysis_history():
    """Get history of AI analyses."""
    return [AnalysisResult(**a) for a in _analysis_history]


# Health check
@router.get("/health")
async def health_check():
    """Health check endpoint."""
    try:
        service = await get_profiling_service()
        tables = await service.get_tables()
        return {
            "status": "healthy",
            "database": "connected",
            "tables_available": len(tables)
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "database": "disconnected",
            "error": str(e)
        }
