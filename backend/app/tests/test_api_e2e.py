"""
E2E Tests for DQM LOCAL AI API
Generated by RTX 3050 (Qwen2.5-Coder-7B-Instruct)
Enhanced with comprehensive test coverage.
"""
import pytest
from httpx import AsyncClient, ASGITransport
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app.main import app


@pytest.fixture
async def client():
    """Create async HTTP client for testing."""
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client


# ============================================================================
# Health Check Tests
# ============================================================================

@pytest.mark.asyncio
async def test_basic_health_check(client):
    """Test basic health check endpoint."""
    response = await client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"
    assert data["app"] == "dqm-local-ai"


@pytest.mark.asyncio
async def test_api_health_check(client):
    """Test API health check endpoint with database status."""
    response = await client.get("/api/health")
    assert response.status_code == 200
    data = response.json()
    assert "status" in data
    assert "database" in data


# ============================================================================
# Profile Endpoint Tests
# ============================================================================

@pytest.mark.asyncio
async def test_list_tables(client):
    """Test listing available tables."""
    response = await client.get("/api/profile/tables")
    assert response.status_code == 200
    tables = response.json()
    assert isinstance(tables, list)
    # Check that whitelist tables are present
    expected_tables = {"customers", "orders", "products", "employees"}
    for table in expected_tables:
        assert table in tables


@pytest.mark.asyncio
async def test_profile_valid_table(client):
    """Test profiling a valid table."""
    response = await client.get("/api/profile/customers")
    assert response.status_code == 200
    data = response.json()
    assert data["table_name"] == "customers"
    assert "row_count" in data
    assert "column_count" in data
    assert "columns" in data
    assert isinstance(data["columns"], list)


@pytest.mark.asyncio
async def test_profile_table_columns(client):
    """Test that table profile includes column details."""
    response = await client.get("/api/profile/products")
    assert response.status_code == 200
    data = response.json()

    # Check column structure
    for column in data["columns"]:
        assert "column_name" in column
        assert "data_type" in column
        assert "null_count" in column
        assert "unique_count" in column


@pytest.mark.asyncio
async def test_profile_invalid_table_blocked(client):
    """Test that non-whitelisted tables are blocked (security)."""
    response = await client.get("/api/profile/users_hacked")
    assert response.status_code == 400
    data = response.json()
    assert "whitelist" in data["detail"].lower()


@pytest.mark.asyncio
async def test_profile_sql_injection_blocked(client):
    """Test that SQL injection attempts are blocked by whitelist."""
    # Attempt SQL injection via table name
    injection_attempts = [
        "customers; DROP TABLE customers;--",
        "customers' OR '1'='1",
        "customers UNION SELECT * FROM pg_shadow",
    ]

    for attempt in injection_attempts:
        response = await client.get(f"/api/profile/{attempt}")
        assert response.status_code == 400, f"SQL injection not blocked: {attempt}"


# ============================================================================
# Rules Endpoint Tests
# ============================================================================

@pytest.mark.asyncio
async def test_list_rules_empty(client):
    """Test listing rules when empty."""
    response = await client.get("/api/rules")
    assert response.status_code == 200
    assert isinstance(response.json(), list)


@pytest.mark.asyncio
async def test_create_rule(client):
    """Test creating a new data quality rule."""
    rule_data = {
        "name": "Test Null Check",
        "description": "Check for null values in contact_name",
        "condition": "contact_name IS NOT NULL",
        "rule_type": "NULL_CHECK",
        "table": "customers",
        "column": "contact_name"
    }
    response = await client.post("/api/rules", json=rule_data)
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Test Null Check"
    assert "id" in data


@pytest.mark.asyncio
async def test_delete_rule(client):
    """Test deleting a rule."""
    # First create a rule
    rule_data = {
        "name": "Rule to Delete",
        "description": "Temporary rule",
        "condition": "1=1"
    }
    create_response = await client.post("/api/rules", json=rule_data)
    assert create_response.status_code == 201
    rule_id = create_response.json()["id"]

    # Then delete it
    delete_response = await client.delete(f"/api/rules/{rule_id}")
    assert delete_response.status_code == 204


@pytest.mark.asyncio
async def test_delete_nonexistent_rule(client):
    """Test deleting a non-existent rule."""
    response = await client.delete("/api/rules/99999")
    assert response.status_code == 404


@pytest.mark.asyncio
async def test_suggest_rules(client):
    """Test rule suggestions for a table."""
    response = await client.post("/api/rules/suggest", json={"table": "customers"})
    assert response.status_code == 200
    data = response.json()
    assert "table" in data
    assert "suggested_rules" in data
    assert isinstance(data["suggested_rules"], list)


@pytest.mark.asyncio
async def test_suggest_rules_invalid_table(client):
    """Test rule suggestions for invalid table."""
    response = await client.post("/api/rules/suggest", json={"table": "invalid_table"})
    assert response.status_code == 400


@pytest.mark.asyncio
async def test_execute_rule(client):
    """Test executing a data quality rule."""
    rule_request = {
        "rule_type": "NULL_CHECK",
        "table": "customers",
        "column": "contact_name",
        "params": {}
    }
    response = await client.post("/api/rules/execute", json=rule_request)
    assert response.status_code == 200
    data = response.json()
    assert "passed" in data or "result" in data


@pytest.mark.asyncio
async def test_execute_rule_invalid_table(client):
    """Test executing rule on invalid table."""
    rule_request = {
        "rule_type": "NULL_CHECK",
        "table": "hacked_table",
        "column": "column",
        "params": {}
    }
    response = await client.post("/api/rules/execute", json=rule_request)
    assert response.status_code == 400


# ============================================================================
# Analysis Endpoint Tests
# ============================================================================

@pytest.mark.asyncio
async def test_analysis_history_empty(client):
    """Test getting analysis history when empty."""
    response = await client.get("/api/analysis/history")
    assert response.status_code == 200
    assert isinstance(response.json(), list)


# ============================================================================
# Root Endpoint Test
# ============================================================================

@pytest.mark.asyncio
async def test_root_endpoint(client):
    """Test root endpoint returns API info."""
    response = await client.get("/")
    assert response.status_code == 200
    data = response.json()
    assert data["name"] == "DQM LOCAL AI"
    assert "version" in data
    assert "generated_by" in data
