"""
DQM LOCAL AI Application - Main Entry Point
Generated by LOCAL AI (RTX 5090 + RTX 3050)
Updated to use REAL database routes
"""
import logging
import time
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request, Response, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from starlette.exceptions import HTTPException as StarletteHTTPException
from starlette.middleware.base import BaseHTTPMiddleware
from typing import Callable, Awaitable

# Import domain-separated routes
from app.routes import (
    data_profiling_router,
    data_quality_router,
    ai_analysis_router
)
# Legacy routes for backward compatibility
from app.api_routes import router as api_router
# Import profiling service for initialization
from app.services.data_profiling_service import get_profiling_service, _profiling_service

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt="%Y-%m-%dT%H:%M:%S",
)
logger = logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager with database initialization."""
    logger.info("Starting DQM LOCAL AI Application...")

    # Initialize database connection pool
    try:
        service = await get_profiling_service()
        tables = await service.get_tables()
        logger.info(f"Database connection verified. Available tables: {len(tables)}")
    except Exception as e:
        logger.error(f"Failed to initialize database: {e}")
        raise

    yield

    # Cleanup database connection on shutdown
    logger.info("Shutting down DQM LOCAL AI Application...")
    if _profiling_service:
        await _profiling_service.disconnect()
        logger.info("Database connection pool closed")


app = FastAPI(
    title="DQM LOCAL AI",
    description="Data Quality Management - Generated by LOCAL AI (RTX 5090 + RTX 3050)",
    version="1.0.0",
    lifespan=lifespan
)


# Middleware for request timing
class RequestTimingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next: Callable[[Request], Awaitable[Response]]) -> Response:
        start_time = time.time()
        response = await call_next(request)
        process_time = (time.time() - start_time) * 1000
        logger.info(f"{request.method} {request.url.path} - {response.status_code} - {process_time:.2f}ms")
        return response


app.add_middleware(RequestTimingMiddleware)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:3001", "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Exception handlers
@app.exception_handler(Exception)
async def unhandled_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error", "type": type(exc).__name__},
    )


@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    logger.error(f"Value error: {exc}")
    return JSONResponse(
        status_code=400,
        content={"detail": str(exc)},
    )


@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail},
    )


@app.exception_handler(StarletteHTTPException)
async def starlette_http_exception_handler(request: Request, exc: StarletteHTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail},
    )


# Health endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "app": "dqm-local-ai", "version": "1.0.0"}


# Root endpoint
@app.get("/")
async def root():
    """Root endpoint with API info."""
    return {
        "name": "DQM LOCAL AI",
        "version": "1.0.0",
        "generated_by": "RTX 5090 + RTX 3050",
        "endpoints": ["/api/profile", "/api/rules", "/api/analysis"]
    }


# Include domain-separated routes (Expert AI pattern)
app.include_router(data_profiling_router)
app.include_router(data_quality_router)
app.include_router(ai_analysis_router)

# Include legacy API routes for backward compatibility
app.include_router(api_router)