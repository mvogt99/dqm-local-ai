"""
Dynamic Database Configuration
Generated by RTX 3050 (Qwen2.5-Coder-7B-Instruct), enhanced by Expert
Enhanced by Expert AI (Claude Opus 4.5) - Added runtime switching capability

V74: Dynamic database configuration with runtime switching
- Environment variable configuration
- PostgreSQL and SQLite backends
- Connection pooling
- Runtime configuration switching
- Connection testing
"""
import os
import asyncio
from typing import Optional, Dict, Any, List
from pydantic_settings import BaseSettings
from pydantic import BaseModel, Field
from functools import lru_cache
import asyncpg
import logging

logger = logging.getLogger(__name__)


class DatabaseSettings(BaseSettings):
    """Database configuration with environment variable support."""

    # Primary connection string (takes priority if set)
    DATABASE_URL: Optional[str] = None

    # Individual connection parameters
    DB_HOST: str = "localhost"
    DB_PORT: int = 5432
    DB_NAME: str = "northwind"
    DB_USER: str = "dqm_user"
    DB_PASSWORD: str = "dqm_password"

    # Connection pool settings
    DB_POOL_SIZE: int = 5
    DB_POOL_MAX_OVERFLOW: int = 10
    DB_POOL_TIMEOUT: int = 30

    # Database type (postgresql or sqlite)
    DB_TYPE: str = "postgresql"

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"
        extra = "ignore"

    def get_connection_string(self) -> str:
        """Build connection string, prioritizing DATABASE_URL if set."""
        if self.DATABASE_URL:
            return self.DATABASE_URL

        if self.DB_TYPE == "sqlite":
            return f"sqlite:///./{self.DB_NAME}.db"

        return (
            f"postgresql://{self.DB_USER}:{self.DB_PASSWORD}"
            f"@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"
        )

    def get_async_connection_string(self) -> str:
        """Build async connection string for asyncpg."""
        if self.DATABASE_URL:
            # Convert postgresql:// to postgresql+asyncpg://
            url = self.DATABASE_URL
            if url.startswith("postgresql://"):
                return url.replace("postgresql://", "postgresql+asyncpg://", 1)
            return url

        if self.DB_TYPE == "sqlite":
            return f"sqlite+aiosqlite:///./{self.DB_NAME}.db"

        return (
            f"postgresql+asyncpg://{self.DB_USER}:{self.DB_PASSWORD}"
            f"@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"
        )


class DatabaseConnection(BaseModel):
    """Model for a database connection configuration."""
    name: str = Field(..., description="Connection name/identifier")
    host: str = Field(..., description="Database host")
    port: int = Field(5432, description="Database port")
    database: str = Field(..., description="Database name")
    username: str = Field(..., description="Database username")
    password: str = Field(..., description="Database password")
    db_type: str = Field("postgresql", description="Database type")
    description: Optional[str] = Field(None, description="Connection description")


class DynamicDatabaseManager:
    """
    Manager for dynamic database configuration switching.

    Supports:
    - Multiple named database connections
    - Runtime connection switching
    - Connection testing
    - Active connection tracking
    """

    def __init__(self):
        self._connections: Dict[str, DatabaseConnection] = {}
        self._active_connection: Optional[str] = None
        self._pools: Dict[str, asyncpg.Pool] = {}

        # Initialize with default connection
        default_settings = get_database_settings()
        self._default_url = default_settings.get_connection_string()
        self._connections["default"] = DatabaseConnection(
            name="default",
            host=default_settings.DB_HOST,
            port=default_settings.DB_PORT,
            database=default_settings.DB_NAME,
            username=default_settings.DB_USER,
            password=default_settings.DB_PASSWORD,
            db_type=default_settings.DB_TYPE,
            description="Default Northwind database"
        )
        self._active_connection = "default"

    def add_connection(self, connection: DatabaseConnection) -> None:
        """Add a new database connection configuration."""
        if connection.name in self._connections:
            logger.warning(f"Overwriting existing connection: {connection.name}")
        self._connections[connection.name] = connection
        logger.info(f"Added database connection: {connection.name}")

    def remove_connection(self, name: str) -> bool:
        """Remove a database connection configuration."""
        if name == "default":
            raise ValueError("Cannot remove the default connection")
        if name in self._connections:
            # Close pool if exists
            if name in self._pools:
                asyncio.create_task(self._pools[name].close())
                del self._pools[name]
            del self._connections[name]
            if self._active_connection == name:
                self._active_connection = "default"
            logger.info(f"Removed database connection: {name}")
            return True
        return False

    def get_connection(self, name: str = None) -> Optional[DatabaseConnection]:
        """Get a specific connection or the active one."""
        name = name or self._active_connection
        return self._connections.get(name)

    def list_connections(self) -> List[Dict[str, Any]]:
        """List all configured connections."""
        return [
            {
                "name": conn.name,
                "host": conn.host,
                "port": conn.port,
                "database": conn.database,
                "db_type": conn.db_type,
                "description": conn.description,
                "is_active": conn.name == self._active_connection
            }
            for conn in self._connections.values()
        ]

    def get_active_connection_name(self) -> str:
        """Get the name of the active connection."""
        return self._active_connection

    def set_active_connection(self, name: str) -> None:
        """Set the active database connection."""
        if name not in self._connections:
            raise ValueError(f"Connection '{name}' not found")
        self._active_connection = name
        logger.info(f"Switched active database connection to: {name}")

    def get_connection_url(self, name: str = None) -> str:
        """Get the connection URL for a named or active connection."""
        conn = self.get_connection(name)
        if not conn:
            return self._default_url

        if conn.db_type == "sqlite":
            return f"sqlite:///./{conn.database}.db"

        return (
            f"postgresql://{conn.username}:{conn.password}"
            f"@{conn.host}:{conn.port}/{conn.database}"
        )

    async def test_connection(self, name: str = None) -> Dict[str, Any]:
        """Test a database connection."""
        url = self.get_connection_url(name)
        conn_name = name or self._active_connection

        try:
            conn = await asyncpg.connect(url)
            try:
                # Test query
                version = await conn.fetchval("SELECT version()")
                tables = await conn.fetch("""
                    SELECT table_name
                    FROM information_schema.tables
                    WHERE table_schema = 'public' AND table_type = 'BASE TABLE'
                    LIMIT 10
                """)

                return {
                    "connection": conn_name,
                    "status": "connected",
                    "database_version": version,
                    "tables_found": len(tables),
                    "sample_tables": [r['table_name'] for r in tables]
                }
            finally:
                await conn.close()
        except Exception as e:
            logger.error(f"Connection test failed for {conn_name}: {e}")
            return {
                "connection": conn_name,
                "status": "failed",
                "error": str(e)
            }

    async def get_pool(self, name: str = None) -> asyncpg.Pool:
        """Get or create a connection pool for the specified connection."""
        name = name or self._active_connection

        if name not in self._pools:
            url = self.get_connection_url(name)
            self._pools[name] = await asyncpg.create_pool(
                url,
                min_size=2,
                max_size=10
            )

        return self._pools[name]

    async def close_all_pools(self) -> None:
        """Close all connection pools."""
        for name, pool in self._pools.items():
            await pool.close()
            logger.info(f"Closed pool for: {name}")
        self._pools.clear()


# Singleton instances
@lru_cache()
def get_database_settings() -> DatabaseSettings:
    """Get cached database settings instance."""
    return DatabaseSettings()


# Global database manager instance
_db_manager: Optional[DynamicDatabaseManager] = None


def get_database_manager() -> DynamicDatabaseManager:
    """Get or create the database manager singleton."""
    global _db_manager
    if _db_manager is None:
        _db_manager = DynamicDatabaseManager()
    return _db_manager


# Convenience exports
database_settings = get_database_settings()
DATABASE_URL = database_settings.get_connection_string()
ASYNC_DATABASE_URL = database_settings.get_async_connection_string()
