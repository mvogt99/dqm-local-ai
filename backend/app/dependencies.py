"""
FastAPI Dependencies for Dependency Injection
Generated by RTX 5090 (Qwen2.5-Coder-32B-Instruct-AWQ)
Enhanced with proper FastAPI patterns.
"""
from contextlib import asynccontextmanager
from typing import AsyncGenerator, Optional
import asyncpg
import logging

from app.config import settings

logger = logging.getLogger(__name__)


class DatabasePool:
    """
    Database connection pool manager.

    Created at app startup, used by FastAPI dependencies to provide
    connections to route handlers via Depends().
    """

    def __init__(self):
        self.pool: Optional[asyncpg.Pool] = None

    async def create_pool(self) -> None:
        """Create the connection pool."""
        self.pool = await asyncpg.create_pool(
            settings.DATABASE_URL,
            min_size=settings.DATABASE_MIN_POOL_SIZE,
            max_size=settings.DATABASE_MAX_POOL_SIZE
        )
        logger.info(f"Database pool created with {settings.DATABASE_MIN_POOL_SIZE}-{settings.DATABASE_MAX_POOL_SIZE} connections")

    async def close_pool(self) -> None:
        """Close the connection pool."""
        if self.pool:
            await self.pool.close()
            logger.info("Database pool closed")

    @asynccontextmanager
    async def get_connection(self) -> AsyncGenerator[asyncpg.Connection, None]:
        """
        Get a connection from the pool.

        Usage:
            async with db_pool.get_connection() as conn:
                result = await conn.fetch(...)
        """
        async with self.pool.acquire() as conn:
            yield conn


# Global pool instance (initialized in lifespan)
db_pool = DatabasePool()


@asynccontextmanager
async def lifespan(app):
    """
    Application lifespan manager.

    Creates database pool on startup, closes on shutdown.
    Usage in main.py:
        app = FastAPI(lifespan=lifespan)
    """
    logger.info("Starting DQM LOCAL AI Application...")

    # Startup: Create database pool
    await db_pool.create_pool()

    # Verify connection
    async with db_pool.get_connection() as conn:
        tables = await conn.fetch("""
            SELECT table_name FROM information_schema.tables
            WHERE table_schema = 'public' AND table_type = 'BASE TABLE'
        """)
        available = [t['table_name'] for t in tables if t['table_name'] in settings.TABLE_WHITELIST]
        logger.info(f"Database connected. Available tables: {len(available)}")

    # Store pool in app state for access in dependencies
    app.state.db_pool = db_pool

    yield  # Application runs here

    # Shutdown: Close database pool
    logger.info("Shutting down DQM LOCAL AI Application...")
    await db_pool.close_pool()


async def get_db_connection() -> AsyncGenerator[asyncpg.Connection, None]:
    """
    FastAPI dependency for database connections.

    Usage:
        @router.get("/tables")
        async def list_tables(conn: asyncpg.Connection = Depends(get_db_connection)):
            result = await conn.fetch(...)

    Each request gets its own connection from the pool.
    Connection is automatically returned to pool when request completes.
    """
    async with db_pool.get_connection() as conn:
        yield conn


async def validate_table_name(table: str) -> str:
    """
    Dependency to validate table names against whitelist.

    Usage:
        @router.get("/profile/{table}")
        async def profile(table: str = Depends(validate_table_name)):
            ...
    """
    from fastapi import HTTPException

    if table not in settings.TABLE_WHITELIST:
        raise HTTPException(
            status_code=400,
            detail=f"Table '{table}' is not in the whitelist. Allowed: {sorted(settings.TABLE_WHITELIST)}"
        )
    return table
