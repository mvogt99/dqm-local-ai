/**
 * DataProfiling Component - V89 Enhancement
 * Multi-table selection support, matching Expert AI architecture
 * Generated by Claude Code with RTX 5090/3050 architecture
 */
import React, { useState, useEffect } from 'react';
import MultiTableSelector from './MultiTableSelector';

const VERSION = 'V89-PROFILE';

function DataProfiling({ apiBase }) {
  const [tables, setTables] = useState([]);
  const [selectedTable, setSelectedTable] = useState('');
  const [selectedTables, setSelectedTables] = useState([]);
  const [columns, setColumns] = useState([]);
  const [profilingResults, setProfilingResults] = useState(null);
  const [batchResults, setBatchResults] = useState(null);
  const [storedResults, setStoredResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // V88: Load tables and ALL stored results on mount
  useEffect(() => {
    fetch(`${apiBase}/data-profiling/tables`)
      .then(res => res.json())
      .then(data => setTables(data))
      .catch(err => setError('Failed to load tables'));

    // V88: Also load any existing stored profiling results on mount
    loadAllStoredResults();
  }, [apiBase]);

  useEffect(() => {
    if (selectedTable) {
      fetch(`${apiBase}/data-profiling/tables/${selectedTable}/columns`)
        .then(res => res.json())
        .then(data => setColumns(data))
        .catch(err => setError('Failed to load columns'));
    }
  }, [selectedTable, apiBase]);

  const runProfiling = async () => {
    if (!selectedTable) return;
    setLoading(true);
    setError(null);
    try {
      const res = await fetch(`${apiBase}/data-profiling/profile/${selectedTable}/run`, {
        method: 'POST'
      });
      const data = await res.json();
      setProfilingResults(data);
      loadStoredResults();
    } catch (err) {
      setError('Profiling failed: ' + err.message);
    } finally {
      setLoading(false);
    }
  };

  // Batch profile multiple tables
  const runBatchProfiling = async () => {
    if (selectedTables.length === 0) {
      setError('Please select at least one table');
      return;
    }
    setLoading(true);
    setError(null);
    setBatchResults(null);

    try {
      const results = { successful: 0, failed: 0, profiles: [] };

      for (const table of selectedTables) {
        try {
          const res = await fetch(`${apiBase}/data-profiling/profile/${table}/run`, {
            method: 'POST'
          });
          const data = await res.json();
          results.profiles.push({ table, success: true, data });
          results.successful++;
        } catch (err) {
          results.profiles.push({ table, success: false, error: err.message });
          results.failed++;
        }
      }

      setBatchResults(results);

      // V86: Load ALL stored results for profiled tables (not just single table)
      // This fixes the "Select a table" message after multi-table profiling
      await loadAllStoredResults();
    } catch (err) {
      setError('Batch profiling failed: ' + err.message);
    } finally {
      setLoading(false);
    }
  };

  const loadStoredResults = async () => {
    try {
      const res = await fetch(`${apiBase}/data-profiling/results?table_name=${selectedTable}`);
      const data = await res.json();
      // V86: Handle both array and object responses
      const results = Array.isArray(data) ? data : (data.results || []);
      setStoredResults(results);
    } catch (err) {
      console.error('Failed to load results:', err);
    }
  };

  // V89: Load ALL stored results without table filter (for multi-table profiling)
  const loadAllStoredResults = async () => {
    console.log(`[${VERSION}] Loading all stored results from ${apiBase}/data-profiling/results`);
    try {
      const res = await fetch(`${apiBase}/data-profiling/results`);
      const data = await res.json();
      console.log(`[${VERSION}] Raw API response:`, data);
      // Handle both array and object responses
      const results = Array.isArray(data) ? data : (data.results || []);
      console.log(`[${VERSION}] Parsed ${results.length} profiling results`);
      setStoredResults(results);
    } catch (err) {
      console.error(`[${VERSION}] Failed to load all results:`, err);
    }
  };

  useEffect(() => {
    if (selectedTable) loadStoredResults();
  }, [selectedTable]);

  return (
    <div className="data-profiling">
      <h2>Data Profiling <span style={{ fontSize: '12px', background: '#4CAF50', color: 'white', padding: '2px 8px', borderRadius: '4px', marginLeft: '8px' }}>{VERSION}</span></h2>

      {/* Multi-Table Selection */}
      <div className="multi-select-section" style={{ marginBottom: '20px' }}>
        <MultiTableSelector
          tables={tables}
          selectedTables={selectedTables}
          onSelectionChange={setSelectedTables}
          disabled={loading}
        />
        <button
          onClick={runBatchProfiling}
          disabled={selectedTables.length === 0 || loading}
          className="btn primary"
          style={{ marginTop: '10px' }}
        >
          {loading ? 'Profiling...' : `Profile Selected (${selectedTables.length})`}
        </button>
      </div>

      {/* Batch Results */}
      {batchResults && (
        <div className="batch-results" style={{
          padding: '15px',
          background: '#f0f9ff',
          borderRadius: '8px',
          marginBottom: '20px'
        }}>
          <h4>Batch Profiling Complete</h4>
          <p>Successful: {batchResults.successful} | Failed: {batchResults.failed}</p>
        </div>
      )}

      {/* Single Table Selection for Details */}
      <div className="controls">
        <h4>View Table Details</h4>
        <select
          value={selectedTable}
          onChange={e => setSelectedTable(e.target.value)}
          className="select"
        >
          <option value="">Select a table for details...</option>
          {tables.map(t => <option key={t} value={t}>{t}</option>)}
        </select>

        <button
          onClick={runProfiling}
          disabled={!selectedTable || loading}
          className="btn secondary"
        >
          {loading ? 'Running...' : 'Run Single'}
        </button>
      </div>

      {error && <div className="error-message">{error}</div>}

      {columns.length > 0 && (
        <div className="columns-info">
          <h3>Columns ({columns.length})</h3>
          <table className="data-table">
            <thead>
              <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Nullable</th>
              </tr>
            </thead>
            <tbody>
              {columns.map(col => (
                <tr key={col.name}>
                  <td>{col.name}</td>
                  <td>{col.type}</td>
                  <td>{col.nullable}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {profilingResults && (
        <div className="profiling-summary">
          <h3>Profiling Complete</h3>
          <p>Columns profiled: {profilingResults.columns_profiled}</p>
          <p>Results stored: {profilingResults.stored}</p>
        </div>
      )}

      {/* V88: Profiling Results Section - Always visible with fallback message */}
      <div className="stored-results">
        <h3>Profiling Results {storedResults.length > 0 ? `(${storedResults.length} columns)` : ''}</h3>
        {storedResults.length === 0 ? (
          <p className="empty-state">
            No profiling results available. Select tables above and click "Profile Selected" to generate profiling data.
          </p>
        ) : storedResults.map((result, idx) => {
            // V86: Handle both flat (Local AI) and nested (Expert AI) formats
            const nullPercent = result.result?.nulls?.null_percentage ?? result.null_percent ?? 0;
            const uniqueCount = result.result?.uniqueness?.unique_values ?? result.unique_count ?? 0;
            const totalRows = result.result?.uniqueness?.total_rows ?? null;
            const minVal = result.result?.statistics?.min ?? result.min_value;
            const maxVal = result.result?.statistics?.max ?? result.max_value;
            const columnName = result.column_name;
            const tableName = result.table_name;

            return (
              <div key={result.id || idx} className="result-card">
                <h4>{tableName ? `${tableName}.` : ''}{columnName}</h4>
                <div className="metrics">
                  <div className="metric">
                    <span className="label">Nulls:</span>
                    <span className={`value ${nullPercent > 0 ? 'warning' : 'success'}`}>
                      {nullPercent?.toFixed(1)}%
                    </span>
                  </div>
                  <div className="metric">
                    <span className="label">Unique:</span>
                    <span className="value info">
                      {uniqueCount}{totalRows ? ` / ${totalRows}` : ''}
                    </span>
                  </div>
                  {(minVal !== undefined && minVal !== null) && (
                    <div className="metric">
                      <span className="label">Range:</span>
                      <span className="value">
                        {minVal} - {maxVal}
                      </span>
                    </div>
                  )}
                </div>
              </div>
            );
          })}
      </div>
    </div>
  );
}

export default DataProfiling;
